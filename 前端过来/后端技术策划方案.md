# 电竞赛事模拟系统 - 后端技术策划方案

## 一、项目概述

### 1.1 项目定位
基于电竞赛事模拟系统策划书，构建一个高性能、可扩展、安全可靠的后端服务系统，支持复杂的赛事管理、积分计算、数据统计和实时更新功能，为前端应用提供稳定的数据服务和业务逻辑支撑。

### 1.2 技术目标
- **高性能**：API响应时间 < 200ms，支持并发用户 > 1000
- **高可用**：服务可用性 ≥ 99.9%，故障恢复时间 < 5分钟
- **可扩展**：微服务架构，支持业务模块独立扩展
- **数据一致性**：事务处理确保数据完整性，实时计算准确性100%

## 二、技术架构方案

### 2.1 整体架构
```
后端服务架构
├── 应用层 (Application Layer)
│   ├── API网关 (API Gateway)
│   ├── 认证服务 (Auth Service)
│   └── 负载均衡 (Load Balancer)
├── 服务层 (Service Layer)
│   ├── 战队管理服务 (Team Service)
│   ├── 赛事管理服务 (Competition Service)
│   ├── 赛程管理服务 (Schedule Service)
│   ├── 积分计算服务 (Score Service)
│   ├── 统计分析服务 (Statistics Service)
│   └── 通知服务 (Notification Service)
├── 业务逻辑层 (Business Logic Layer)
│   ├── 赛制引擎 (Competition Engine)
│   ├── 积分引擎 (Scoring Engine)
│   ├── 模拟引擎 (Simulation Engine)
│   ├── 抽签引擎 (Draw Engine)
│   └── 数据验证 (Validation)
├── 数据访问层 (Data Access Layer)
│   ├── 数据库层 (Database)
│   ├── 缓存层 (Cache)
│   └── 文件存储 (File Storage)
└── 基础设施层 (Infrastructure Layer)
    ├── 监控告警 (Monitoring)
    ├── 日志管理 (Logging)
    └── 配置管理 (Configuration)
```

### 2.2 核心技术栈选型

#### 2.2.1 主服务框架
- **后端框架**: Node.js + Express.js 4.18+
  - 选择理由：开发效率高、生态丰富、JavaScript全栈一致性
  - 替代方案：Nest.js（企业级项目）、Fastify（高性能要求）
- **开发语言**: TypeScript 5.0+
  - 选择理由：类型安全、代码提示、重构友好、团队协作

#### 2.2.2 数据库系统
- **主数据库**: PostgreSQL 15+
  - 选择理由：事务支持完善、JSON字段支持、复杂查询性能优秀
  - 配置：读写分离、连接池管理、索引优化
- **缓存数据库**: Redis 7.0+
  - 选择理由：高性能、数据结构丰富、分布式支持
  - 应用场景：会话存储、计算结果缓存、实时数据缓存

#### 2.2.3 API设计
- **API风格**: RESTful API + GraphQL
  - RESTful：常规CRUD操作
  - GraphQL：复杂数据查询和实时订阅
- **API文档**: OpenAPI 3.0 + Swagger UI
  - 自动生成API文档
  - 接口测试支持

#### 2.2.4 消息队列
- **消息系统**: Redis Pub/Sub + Bull Queue
  - 选择理由：轻量级、延迟低、易于部署
  - 应用场景：赛事结果通知、积分计算任务、数据同步

### 2.3 数据模型设计

#### 2.3.1 核心实体关系
```sql
-- 战队表
CREATE TABLE teams (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) NOT NULL UNIQUE,
    region_id UUID NOT NULL REFERENCES regions(id),
    power_rating INTEGER CHECK (power_rating >= 0 AND power_rating <= 100),
    founded_date DATE,
    total_matches INTEGER DEFAULT 0,
    total_wins INTEGER DEFAULT 0,
    total_losses INTEGER DEFAULT 0,
    net_round_difference INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 赛区表
CREATE TABLE regions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(50) NOT NULL UNIQUE,
    display_order INTEGER,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 赛季表
CREATE TABLE seasons (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) NOT NULL,
    year INTEGER NOT NULL,
    status VARCHAR(20) DEFAULT 'planning', -- planning, active, completed
    current_phase VARCHAR(50), -- spring_regular, spring_playoffs, msi, etc.
    start_date DATE,
    end_date DATE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 赛事表
CREATE TABLE competitions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    season_id UUID NOT NULL REFERENCES seasons(id),
    type VARCHAR(30) NOT NULL, -- spring, summer, msi, worlds, intercontinental
    name VARCHAR(100) NOT NULL,
    status VARCHAR(20) DEFAULT 'upcoming', -- upcoming, active, completed
    format JSONB NOT NULL, -- 赛制配置
    scoring_rules JSONB NOT NULL, -- 积分规则
    start_date DATE,
    end_date DATE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 比赛表
CREATE TABLE matches (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    competition_id UUID NOT NULL REFERENCES competitions(id),
    team_a_id UUID NOT NULL REFERENCES teams(id),
    team_b_id UUID NOT NULL REFERENCES teams(id),
    round_number INTEGER,
    phase VARCHAR(50), -- regular, playoffs, quarterfinals, etc.
    format VARCHAR(10), -- BO3, BO5
    score_a INTEGER DEFAULT 0,
    score_b INTEGER DEFAULT 0,
    winner_id UUID REFERENCES teams(id),
    status VARCHAR(20) DEFAULT 'scheduled', -- scheduled, in_progress, completed
    scheduled_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE,
    match_data JSONB, -- 额外比赛数据
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 积分记录表
CREATE TABLE score_records (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    team_id UUID NOT NULL REFERENCES teams(id),
    competition_id UUID NOT NULL REFERENCES competitions(id),
    match_id UUID REFERENCES matches(id),
    points INTEGER NOT NULL,
    point_type VARCHAR(30), -- match_win, tournament_placement, etc.
    season_year INTEGER NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 抽签记录表
CREATE TABLE draw_records (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    competition_id UUID NOT NULL REFERENCES competitions(id),
    phase VARCHAR(50) NOT NULL,
    draw_data JSONB NOT NULL, -- 抽签结果数据
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

#### 2.3.2 索引优化策略
```sql
-- 性能关键索引
CREATE INDEX idx_teams_region ON teams(region_id);
CREATE INDEX idx_teams_power_rating ON teams(power_rating);
CREATE INDEX idx_matches_competition ON matches(competition_id);
CREATE INDEX idx_matches_teams ON matches(team_a_id, team_b_id);
CREATE INDEX idx_matches_date ON matches(scheduled_at);
CREATE INDEX idx_score_records_team_season ON score_records(team_id, season_year);
CREATE INDEX idx_score_records_competition ON score_records(competition_id);

-- 复合索引
CREATE INDEX idx_matches_competition_phase ON matches(competition_id, phase);
CREATE INDEX idx_teams_region_rating ON teams(region_id, power_rating);
```

## 三、核心功能模块技术实现

### 3.1 战队管理服务

#### 3.1.1 服务架构
```typescript
// 战队管理服务
class TeamService {
    constructor(
        private teamRepository: TeamRepository,
        private cacheService: CacheService,
        private eventBus: EventBus
    ) {}

    // 创建战队
    async createTeam(teamData: CreateTeamDto): Promise<Team> {
        const team = await this.teamRepository.create(teamData);
        await this.cacheService.invalidate(`region:${team.regionId}:teams`);
        this.eventBus.emit('team.created', team);
        return team;
    }

    // 更新战队信息
    async updateTeam(id: string, updateData: UpdateTeamDto): Promise<Team> {
        const team = await this.teamRepository.update(id, updateData);
        await this.cacheService.invalidate([
            `team:${id}`,
            `region:${team.regionId}:teams`
        ]);
        this.eventBus.emit('team.updated', team);
        return team;
    }

    // 获取战队统计
    async getTeamStatistics(teamId: string): Promise<TeamStatistics> {
        const cacheKey = `team:${teamId}:stats`;
        let stats = await this.cacheService.get(cacheKey);

        if (!stats) {
            stats = await this.calculateTeamStatistics(teamId);
            await this.cacheService.set(cacheKey, stats, 300); // 5分钟缓存
        }

        return stats;
    }

    // 计算战队统计数据
    private async calculateTeamStatistics(teamId: string): Promise<TeamStatistics> {
        const [matches, scores] = await Promise.all([
            this.teamRepository.getTeamMatches(teamId),
            this.teamRepository.getTeamScores(teamId)
        ]);

        return {
            totalMatches: matches.length,
            wins: matches.filter(m => m.winnerId === teamId).length,
            losses: matches.filter(m => m.winnerId !== teamId && m.winnerId !== null).length,
            winRate: this.calculateWinRate(matches, teamId),
            totalPoints: scores.reduce((sum, score) => sum + score.points, 0),
            averagePointsPerCompetition: this.calculateAveragePoints(scores)
        };
    }
}
```

#### 3.1.2 数据访问层
```typescript
// 战队数据访问层
class TeamRepository {
    constructor(private db: Database) {}

    async create(teamData: CreateTeamDto): Promise<Team> {
        const query = `
            INSERT INTO teams (name, region_id, power_rating, founded_date)
            VALUES ($1, $2, $3, $4)
            RETURNING *
        `;
        const result = await this.db.query(query, [
            teamData.name,
            teamData.regionId,
            teamData.powerRating,
            teamData.foundedDate
        ]);
        return result.rows[0];
    }

    async getTeamsByRegion(regionId: string): Promise<Team[]> {
        const query = `
            SELECT t.*, r.name as region_name
            FROM teams t
            JOIN regions r ON t.region_id = r.id
            WHERE t.region_id = $1
            ORDER BY t.power_rating DESC
        `;
        const result = await this.db.query(query, [regionId]);
        return result.rows;
    }

    async getTeamMatches(teamId: string, limit?: number): Promise<Match[]> {
        const query = `
            SELECT m.*, ta.name as team_a_name, tb.name as team_b_name
            FROM matches m
            JOIN teams ta ON m.team_a_id = ta.id
            JOIN teams tb ON m.team_b_id = tb.id
            WHERE m.team_a_id = $1 OR m.team_b_id = $1
            ORDER BY m.completed_at DESC
            ${limit ? 'LIMIT $2' : ''}
        `;
        const params = limit ? [teamId, limit] : [teamId];
        const result = await this.db.query(query, params);
        return result.rows;
    }
}
```

### 3.2 赛程管理服务

#### 3.2.1 服务架构
```typescript
// 赛程管理服务
class ScheduleService {
    constructor(
        private scheduleRepository: ScheduleRepository,
        private matchService: MatchService,
        private simulationEngine: SimulationEngine,
        private cacheService: CacheService,
        private eventBus: EventBus
    ) {}

    // 获取当前赛程状态
    async getCurrentSchedule(competitionId: string): Promise<ScheduleStatus> {
        const cacheKey = `schedule:${competitionId}:current`;
        let schedule = await this.cacheService.get(cacheKey);

        if (!schedule) {
            schedule = await this.calculateCurrentSchedule(competitionId);
            await this.cacheService.set(cacheKey, schedule, 600); // 10分钟缓存
        }

        return schedule;
    }

    // 推进到下一轮
    async proceedToNextRound(competitionId: string): Promise<RoundResult> {
        const competition = await this.getCompetition(competitionId);
        if (!competition) {
            throw new Error('Competition not found');
        }

        const currentRound = await this.getCurrentRound(competitionId);
        const nextRoundMatches = await this.getNextRoundMatches(competitionId, currentRound + 1);

        if (nextRoundMatches.length === 0) {
            throw new Error('No more rounds available');
        }

        // 模拟当前轮次的所有比赛
        const simulationResults = await this.simulateRoundMatches(nextRoundMatches);

        // 更新比赛结果
        await this.updateMatchResults(simulationResults);

        // 更新积分榜
        const updatedScoreboard = await this.updateScoreboard(competitionId, simulationResults);

        // 更新轮次状态
        await this.updateRoundStatus(competitionId, currentRound + 1, 'completed');

        // 清除缓存
        await this.invalidateScheduleCache(competitionId);

        // 发送事件通知
        this.eventBus.emit('round.completed', {
            competitionId,
            round: currentRound + 1,
            results: simulationResults,
            scoreboard: updatedScoreboard
        });

        return {
            round: currentRound + 1,
            matches: simulationResults,
            scoreboard: updatedScoreboard,
            nextRound: await this.getNextAvailableRound(competitionId)
        };
    }

    // 模拟轮次比赛
    private async simulateRoundMatches(matches: Match[]): Promise<MatchResult[]> {
        const results: MatchResult[] = [];

        for (const match of matches) {
            const [teamA, teamB] = await Promise.all([
                this.getTeamById(match.teamAId),
                this.getTeamById(match.teamBId)
            ]);

            const result = await this.simulationEngine.simulateMatch(teamA, teamB);
            results.push({
                matchId: match.id,
                teamAId: match.teamAId,
                teamBId: match.teamBId,
                scoreA: result.scoreA,
                scoreB: result.scoreB,
                winnerId: result.winnerId,
                simulatedAt: new Date()
            });
        }

        return results;
    }

    // 计算当前赛程状态
    private async calculateCurrentSchedule(competitionId: string): Promise<ScheduleStatus> {
        const [competition, allMatches, currentRound] = await Promise.all([
            this.getCompetition(competitionId),
            this.getAllMatches(competitionId),
            this.getCurrentRound(competitionId)
        ]);

        const totalRounds = await this.getTotalRounds(competitionId);
        const completedMatches = allMatches.filter(m => m.status === 'completed');
        const upcomingMatches = allMatches.filter(m => m.status === 'scheduled' && m.roundNumber === currentRound + 1);

        return {
            competitionId,
            currentRound,
            totalRounds,
            completedMatches: completedMatches.length,
            totalMatches: allMatches.length,
            upcomingMatches,
            isCompleted: currentRound >= totalRounds,
            scoreboard: await this.getCurrentScoreboard(competitionId)
        };
    }
}
```

#### 3.2.2 战力模拟引擎
```typescript
// 战力模拟计算引擎
class SimulationEngine {
    private readonly BASE_RANDOMNESS = 0.2; // 基础随机性因子
    private readonly POWER_SCALING = 0.015; // 战力影响系数

    // 模拟单场比赛
    async simulateMatch(teamA: Team, teamB: Team): Promise<MatchSimulationResult> {
        // 获取战队当前状态
        const teamAStats = await this.getTeamCurrentStats(teamA.id);
        const teamBStats = await this.getTeamCurrentStats(teamB.id);

        // 计算调整后的战力值
        const adjustedPowerA = this.calculateAdjustedPower(teamA, teamAStats);
        const adjustedPowerB = this.calculateAdjustedPower(teamB, teamBStats);

        // 计算胜率
        const winProbabilityA = this.calculateWinProbability(adjustedPowerA, adjustedPowerB);

        // 进行比赛模拟
        const matchResult = this.simulateMatchExecution(winProbabilityA);

        // 记录模拟日志
        await this.logSimulation(teamA, teamB, matchResult, {
            adjustedPowerA,
            adjustedPowerB,
            winProbabilityA
        });

        return {
            scoreA: matchResult.scoreA,
            scoreB: matchResult.scoreB,
            winnerId: matchResult.winnerId,
            simulationData: {
                winProbability: winProbabilityA,
                powerDifference: adjustedPowerA - adjustedPowerB,
                randomFactor: matchResult.randomFactor
            }
        };
    }

    // 计算调整后的战力值
    private calculateAdjustedPower(team: Team, stats: TeamCurrentStats): number {
        let adjustedPower = team.powerRating;

        // 考虑最近表现
        if (stats.recentMatches.length > 0) {
            const recentWinRate = stats.recentWins / stats.recentMatches.length;
            const formFactor = (recentWinRate - 0.5) * 10; // -5 到 +5 的调整
            adjustedPower += formFactor;
        }

        // 考虑连胜/连败
        if (stats.currentStreak > 0) {
            adjustedPower += Math.min(stats.currentStreak * 2, 10); // 连胜加成，最多+10
        } else if (stats.currentStreak < 0) {
            adjustedPower -= Math.min(Math.abs(stats.currentStreak) * 1.5, 8); // 连败减成，最多-8
        }

        // 限制在合理范围内
        return Math.max(0, Math.min(100, adjustedPower));
    }

    // 计算胜率
    private calculateWinProbability(powerA: number, powerB: number): number {
        const powerDiff = powerA - powerB;

        // 使用修正的Sigmoid函数
        const scaledDiff = powerDiff * this.POWER_SCALING;
        const baseProbability = 1 / (1 + Math.exp(-scaledDiff));

        // 添加基础随机性，确保没有100%的胜率
        const minProbability = 0.1;
        const maxProbability = 0.9;

        return Math.max(minProbability, Math.min(maxProbability, baseProbability));
    }

    // 执行比赛模拟
    private simulateMatchExecution(winProbabilityA: number): MatchExecutionResult {
        const randomFactor = Math.random();
        const isTeamAWin = randomFactor < winProbabilityA;

        // 根据胜率差距决定比分
        const scoreDiff = Math.abs(winProbabilityA - 0.5);
        let scoreA: number, scoreB: number;

        if (scoreDiff > 0.25) {
            // 实力差距较大，更容易出现2-0
            if (Math.random() > 0.3) {
                [scoreA, scoreB] = isTeamAWin ? [2, 0] : [0, 2];
            } else {
                [scoreA, scoreB] = isTeamAWin ? [2, 1] : [1, 2];
            }
        } else {
            // 实力接近，更容易出现2-1
            if (Math.random() > 0.4) {
                [scoreA, scoreB] = isTeamAWin ? [2, 1] : [1, 2];
            } else {
                [scoreA, scoreB] = isTeamAWin ? [2, 0] : [0, 2];
            }
        }

        return {
            scoreA,
            scoreB,
            winnerId: scoreA > scoreB ? 'teamA' : 'teamB',
            randomFactor
        };
    }

    // 批量模拟轮次
    async simulateRound(matches: Match[]): Promise<MatchSimulationResult[]> {
        const results: MatchSimulationResult[] = [];

        // 并行模拟所有比赛
        const simulationPromises = matches.map(async (match) => {
            const [teamA, teamB] = await Promise.all([
                this.getTeamById(match.teamAId),
                this.getTeamById(match.teamBId)
            ]);

            return this.simulateMatch(teamA, teamB);
        });

        const simulationResults = await Promise.all(simulationPromises);

        // 组装结果
        for (let i = 0; i < matches.length; i++) {
            results.push({
                matchId: matches[i].id,
                ...simulationResults[i]
            });
        }

        return results;
    }

    // 记录模拟日志
    private async logSimulation(
        teamA: Team,
        teamB: Team,
        result: MatchExecutionResult,
        metadata: any
    ): Promise<void> {
        const logEntry = {
            timestamp: new Date(),
            teamA: { id: teamA.id, name: teamA.name, power: metadata.adjustedPowerA },
            teamB: { id: teamB.id, name: teamB.name, power: metadata.adjustedPowerB },
            result: {
                score: `${result.scoreA}-${result.scoreB}`,
                winner: result.winnerId
            },
            simulation: {
                winProbability: metadata.winProbabilityA,
                randomFactor: result.randomFactor
            }
        };

        // 记录到日志系统
        await this.logger.info('Match simulation completed', logEntry);
    }
}
```

### 3.4 自动赛事生成服务 🆕

#### 3.4.1 核心业务逻辑重构
**重大架构调整**：基于甲方需求，赛事创建从手动操作转为完全自动化机制。

```typescript
// 自动赛事生成服务
class AutoTournamentService {
    constructor(
        private competitionService: CompetitionService,
        private teamService: TeamService,
        private ruleEngine: RuleEngine,
        private eventBus: EventBus,
        private logger: Logger
    ) {}

    // 核心监听机制：监听赛事状态变化
    async onCompetitionStatusChanged(competition: Competition): Promise<void> {
        if (competition.status === 'completed') {
            await this.checkAndTriggerAutoGeneration(competition)
        }
    }

    // 检查并触发自动生成
    private async checkAndTriggerAutoGeneration(completedCompetition: Competition): Promise<void> {
        const applicableRules = await this.ruleEngine.findApplicableRules(completedCompetition)

        this.logger.info(`Found ${applicableRules.length} applicable rules for competition ${completedCompetition.id}`)

        for (const rule of applicableRules) {
            try {
                const result = await this.executeAutoGeneration(rule, completedCompetition)
                this.eventBus.emit('auto-tournament.generated', {
                    rule,
                    sourceCompetition: completedCompetition,
                    generatedCompetition: result.competition,
                    selectedTeams: result.teams
                })
            } catch (error) {
                this.logger.error(`Auto generation failed for rule ${rule.id}`, error)
                this.eventBus.emit('auto-tournament.failed', { rule, error })
            }
        }
    }

    // 执行自动生成逻辑
    private async executeAutoGeneration(
        rule: AutoGenerationRule,
        sourceCompetition: Competition
    ): Promise<AutoGenerationResult> {
        // 1. 检查是否已存在相同类型的赛事
        const existingCompetition = await this.competitionService.findExisting(
            rule.targetCompetitionType,
            sourceCompetition.seasonId
        )

        if (existingCompetition) {
            throw new Error(`Competition ${rule.targetCompetitionType} already exists for season`)
        }

        // 2. 根据规则选择参赛队伍
        const selectedTeams = await this.selectTeamsByRule(rule, sourceCompetition)

        if (selectedTeams.length < rule.minimumTeams) {
            throw new Error(`Insufficient teams: ${selectedTeams.length} < ${rule.minimumTeams}`)
        }

        // 3. 创建新赛事
        const newCompetition = await this.competitionService.createAutoGenerated({
            name: rule.competitionName,
            type: rule.targetCompetitionType,
            format: rule.format,
            seasonId: sourceCompetition.seasonId,
            teams: selectedTeams,
            autoGenerated: true,
            sourceCompetitionId: sourceCompetition.id,
            generationRuleId: rule.id
        })

        // 4. 生成初始赛程（如需要）
        if (rule.autoGenerateSchedule) {
            await this.competitionService.generateSchedule(newCompetition.id)
        }

        // 5. 记录生成历史
        await this.logAutoGeneration(rule, sourceCompetition, newCompetition, selectedTeams)

        return {
            competition: newCompetition,
            teams: selectedTeams,
            rule
        }
    }

    // 智能队伍选择算法
    private async selectTeamsByRule(
        rule: AutoGenerationRule,
        sourceCompetition: Competition
    ): Promise<Team[]> {
        switch (rule.teamSelectionStrategy) {
            case 'regional_champions':
                return this.selectRegionalChampions(rule.targetRegions)

            case 'playoff_winners':
                return this.selectPlayoffWinners(sourceCompetition, rule.teamCount)

            case 'top_ranked_teams':
                return this.selectTopRankedTeams(rule.teamCount, rule.targetRegions)

            case 'intercontinental_qualified':
                return this.selectIntercontinentalQualified(rule.teamCount)

            default:
                throw new Error(`Unknown team selection strategy: ${rule.teamSelectionStrategy}`)
        }
    }

    // 获取赛区冠军
    private async selectRegionalChampions(targetRegions: string[]): Promise<Team[]> {
        const champions: Team[] = []

        for (const regionId of targetRegions) {
            // 查找该赛区最近完成的季后赛
            const recentPlayoffs = await this.competitionService.findRecentPlayoffs(regionId)

            if (recentPlayoffs) {
                const champion = await this.getPlayoffChampion(recentPlayoffs.id)
                if (champion) {
                    champions.push(champion)
                }
            } else {
                // 如果没有季后赛，选择积分最高的队伍
                const topTeam = await this.teamService.getTopTeamByRegion(regionId)
                if (topTeam) {
                    champions.push(topTeam)
                }
            }
        }

        return champions
    }

    // 获取季后赛获胜者
    private async selectPlayoffWinners(
        playoffCompetition: Competition,
        count: number
    ): Promise<Team[]> {
        // 根据季后赛结果排序，选择前N名
        const rankedTeams = await this.competitionService.getRankedTeams(playoffCompetition.id)
        return rankedTeams.slice(0, count)
    }

    // 洲际赛资格队伍选择（跨年度积分）
    private async selectIntercontinentalQualified(count: number): Promise<Team[]> {
        const currentYear = new Date().getFullYear()
        const previousYear = currentYear - 1

        // 计算跨年度积分排名
        const crossYearRanking = await this.teamService.getCrossYearRanking(
            previousYear,
            currentYear
        )

        return crossYearRanking.slice(0, count)
    }

    // 记录自动生成历史
    private async logAutoGeneration(
        rule: AutoGenerationRule,
        source: Competition,
        generated: Competition,
        teams: Team[]
    ): Promise<void> {
        const logEntry = {
            ruleId: rule.id,
            ruleName: rule.name,
            sourceCompetitionId: source.id,
            sourceCompetitionName: source.name,
            generatedCompetitionId: generated.id,
            generatedCompetitionName: generated.name,
            selectedTeamIds: teams.map(t => t.id),
            selectedTeamNames: teams.map(t => t.name),
            executedAt: new Date(),
            seasonId: source.seasonId
        }

        await this.autoGenerationLogRepository.create(logEntry)

        this.logger.info('Auto generation completed', logEntry)
    }
}
```

#### 3.4.2 规则引擎设计
```typescript
// 规则引擎
class RuleEngine {
    private rules: AutoGenerationRule[] = [
        {
            id: 'spring-regular-to-playoffs',
            name: '春季常规赛→春季季后赛',
            trigger: {
                competitionType: 'spring',
                format: 'regular_season',
                status: 'completed'
            },
            action: {
                targetCompetitionType: 'spring',
                format: 'playoffs',
                competitionName: '春季季后赛',
                teamSelectionStrategy: 'top_ranked_teams',
                teamCount: 8,
                autoGenerateSchedule: true
            },
            enabled: true
        },
        {
            id: 'summer-playoffs-to-worlds',
            name: '夏季季后赛→全球总决赛',
            trigger: {
                competitionType: 'summer',
                format: 'playoffs',
                status: 'completed'
            },
            action: {
                targetCompetitionType: 'worlds',
                format: 'worlds_format',
                competitionName: '全球总决赛',
                teamSelectionStrategy: 'regional_champions',
                targetRegions: ['LPL', 'LCK', 'LEC', 'LCS'],
                teamCount: 16,
                autoGenerateSchedule: true
            },
            enabled: true
        },
        {
            id: 'worlds-to-intercontinental',
            name: '全球总决赛→洲际超级杯',
            trigger: {
                competitionType: 'worlds',
                status: 'completed'
            },
            action: {
                targetCompetitionType: 'intercontinental',
                format: 'four_stage',
                competitionName: '洲际超级杯',
                teamSelectionStrategy: 'intercontinental_qualified',
                teamCount: 16,
                autoGenerateSchedule: false, // 需要分阶段生成
                requiresCrossYearRanking: true
            },
            enabled: true
        }
    ]

    // 查找适用规则
    async findApplicableRules(competition: Competition): Promise<AutoGenerationRule[]> {
        return this.rules.filter(rule => {
            if (!rule.enabled) return false

            const trigger = rule.trigger

            // 检查赛事类型
            if (trigger.competitionType && trigger.competitionType !== competition.type) {
                return false
            }

            // 检查赛制格式
            if (trigger.format && trigger.format !== competition.format) {
                return false
            }

            // 检查状态
            if (trigger.status && trigger.status !== competition.status) {
                return false
            }

            return true
        })
    }

    // 动态更新规则
    async updateRule(ruleId: string, updates: Partial<AutoGenerationRule>): Promise<void> {
        const ruleIndex = this.rules.findIndex(rule => rule.id === ruleId)
        if (ruleIndex !== -1) {
            this.rules[ruleIndex] = { ...this.rules[ruleIndex], ...updates }
            await this.persistRules()
        }
    }

    // 添加自定义规则
    async addCustomRule(rule: AutoGenerationRule): Promise<void> {
        this.rules.push(rule)
        await this.persistRules()
    }
}
```

#### 3.4.3 数据聚合服务增强
```typescript
// 横幅数据聚合服务
class BannerDataService {
    // 获取赛事横幅数据
    async getCompetitionBannerData(type?: CompetitionType): Promise<CompetitionBannerData[]> {
        const competitions = type
            ? await this.competitionRepository.findByType(type)
            : await this.competitionRepository.findAll()

        const bannerData = await Promise.all(
            competitions.map(async (competition) => {
                const [champion, regionCount, participantCount] = await Promise.all([
                    this.getCompetitionChampion(competition.id),
                    this.getParticipatingRegionCount(competition.id),
                    this.getParticipantCount(competition.id)
                ])

                return {
                    id: competition.id,
                    name: competition.name,
                    type: competition.type,
                    status: competition.status,
                    format: competition.format,
                    champion,
                    regionCount,
                    participantCount,
                    createdAt: competition.createdAt,
                    scheduledAt: competition.scheduledAt,
                    completedAt: competition.completedAt,
                    isAutoGenerated: competition.autoGenerated || false
                }
            })
        )

        return bannerData.sort((a, b) =>
            new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
        )
    }

    // 获取冠军墙数据
    async getChampionsWallData(competitionType?: CompetitionType): Promise<ChampionWallData[]> {
        const completedCompetitions = await this.competitionRepository.findCompleted(competitionType)

        const championsData = await Promise.all(
            completedCompetitions.map(async (competition) => {
                const champion = await this.getCompetitionChampion(competition.id)
                const region = champion ? await this.regionRepository.findById(champion.regionId) : null

                return {
                    competitionId: competition.id,
                    competitionName: competition.name,
                    competitionType: competition.type,
                    championTeam: champion,
                    championRegion: region,
                    completedAt: competition.completedAt,
                    season: await this.getCompetitionSeason(competition.id)
                }
            })
        )

        return championsData
            .filter(data => data.championTeam !== null)
            .sort((a, b) =>
                new Date(b.completedAt).getTime() - new Date(a.completedAt).getTime()
            )
    }

    // 获取年度汇总数据
    async getAnnualSummaryData(year: number): Promise<AnnualSummaryData> {
        const [competitions, statistics, timeline] = await Promise.all([
            this.competitionRepository.findByYear(year),
            this.calculateYearStatistics(year),
            this.buildYearTimeline(year)
        ])

        return {
            year,
            competitions: await this.transformToCompetitionBannerData(competitions),
            statistics,
            timeline,
            championsWall: await this.getChampionsWallData(),
            totalCompetitions: competitions.length,
            completedCompetitions: competitions.filter(c => c.status === 'completed').length,
            ongoingCompetitions: competitions.filter(c => c.status === 'ongoing').length
        }
    }
}
```

### 3.5 荣誉殿堂服务 🆕

#### 3.5.1 核心服务设计
**需求背景**：甲方要求将"数据中心"重命名为"荣誉殿堂"，作为官方数据展示中心，记录历史荣誉。

```typescript
// 荣誉殿堂服务
class HonorHallService {
    constructor(
        private competitionRepository: CompetitionRepository,
        private teamRepository: TeamRepository,
        private scoreRepository: ScoreRecordRepository,
        private seasonRepository: SeasonRepository,
        private cacheService: CacheService
    ) {}

    // 获取赛季荣誉数据
    async getSeasonHonorData(seasonId: string): Promise<SeasonHonorData> {
        const cacheKey = `honor:season:${seasonId}`;
        let data = await this.cacheService.get(cacheKey);

        if (!data) {
            data = await this.calculateSeasonHonorData(seasonId);
            await this.cacheService.set(cacheKey, data, 3600); // 1小时缓存
        }

        return data;
    }

    // 计算赛季荣誉数据
    private async calculateSeasonHonorData(seasonId: string): Promise<SeasonHonorData> {
        const [
            regionalHonors,
            globalHonors,
            intercontinentalHonors,
            annualRankings,
            statistics
        ] = await Promise.all([
            this.getRegionalHonors(seasonId),
            this.getGlobalHonors(seasonId),
            this.getIntercontinentalHonors(seasonId),
            this.getAnnualRankings(seasonId),
            this.getSeasonStatistics(seasonId)
        ]);

        return {
            seasonId,
            seasonYear: await this.getSeasonYear(seasonId),
            regionalHonors,
            globalHonors,
            intercontinentalHonors,
            annualRankings,
            statistics,
            lastUpdated: new Date()
        };
    }

    // 获取赛区赛荣誉（春季赛 + 夏季赛）
    private async getRegionalHonors(seasonId: string): Promise<RegionalHonorsData> {
        const regions = await this.getActiveRegions();

        const springHonors = await Promise.all(
            regions.map(region => this.getRegionCompetitionHonors(seasonId, region.id, 'spring'))
        );

        const summerHonors = await Promise.all(
            regions.map(region => this.getRegionCompetitionHonors(seasonId, region.id, 'summer'))
        );

        return {
            spring: springHonors.filter(honor => honor !== null),
            summer: summerHonors.filter(honor => honor !== null)
        };
    }

    // 获取单个赛区的赛事荣誉
    private async getRegionCompetitionHonors(
        seasonId: string,
        regionId: string,
        competitionType: 'spring' | 'summer'
    ): Promise<RegionalHonor | null> {
        // 查找该赛区该类型的季后赛
        const playoffCompetition = await this.competitionRepository.findRegionPlayoffs(
            seasonId,
            regionId,
            competitionType
        );

        if (!playoffCompetition || playoffCompetition.status !== 'completed') {
            return null;
        }

        // 获取前三名队伍
        const rankings = await this.getCompetitionRankings(playoffCompetition.id);
        const region = await this.regionRepository.findById(regionId);

        return {
            regionId,
            regionName: region.name,
            competitionId: playoffCompetition.id,
            competitionType,
            champion: await this.buildTeamAchievement(rankings[0], playoffCompetition),
            runnerUp: await this.buildTeamAchievement(rankings[1], playoffCompetition),
            thirdPlace: await this.buildTeamAchievement(rankings[2], playoffCompetition)
        };
    }

    // 获取全球赛荣誉（MSI + 世界赛）
    private async getGlobalHonors(seasonId: string): Promise<GlobalHonorsData> {
        const [msiHonor, worldsHonor] = await Promise.all([
            this.getGlobalCompetitionHonor(seasonId, 'msi'),
            this.getGlobalCompetitionHonor(seasonId, 'worlds')
        ]);

        return {
            msi: msiHonor,
            worlds: worldsHonor
        };
    }

    // 获取年度积分排名
    private async getAnnualRankings(seasonId: string): Promise<AnnualRankingsData> {
        const season = await this.seasonRepository.findById(seasonId);

        // 计算年度总积分排名
        const overallRankings = await this.calculateOverallRankings(season.year);

        // 计算各赛区前三
        const regions = await this.getActiveRegions();
        const regionalRankings = await Promise.all(
            regions.map(region => this.calculateRegionalTopThree(season.year, region.id))
        );

        return {
            topThree: overallRankings.slice(0, 3),
            regionalTop: regionalRankings
        };
    }

    // 获取所有历史记录
    async getAllHistoricalRecords(): Promise<HistoricalRecordsData> {
        const seasons = await this.seasonRepository.findAllCompleted();

        const records = await Promise.all(
            seasons.map(async (season) => {
                const honorData = await this.getSeasonHonorData(season.id);
                return {
                    seasonId: season.id,
                    seasonYear: season.year,
                    summary: this.createSeasonSummary(honorData)
                };
            })
        );

        return {
            seasons: records,
            totalSeasons: seasons.length,
            totalCompetitions: records.reduce((sum, r) => sum + r.summary.competitionCount, 0),
            allTimeChampions: await this.getAllTimeChampions()
        };
    }
}
```typescript
// 赛制引擎 - 处理不同类型赛事的赛程生成
class CompetitionEngine {
    // 联赛常规赛赛程生成
    generateRegularSeasonSchedule(teams: Team[]): Match[] {
        const matches: Match[] = [];
        const teamCount = teams.length;

        // 双循环赛程算法
        for (let round = 0; round < (teamCount - 1) * 2; round++) {
            for (let match = 0; match < teamCount / 2; match++) {
                const home = (round + match) % (teamCount - 1);
                const away = (teamCount - 1 - match + round) % (teamCount - 1);

                // 确保最后一个队伍的处理
                const homeTeam = home === teamCount - 1 ? teamCount - 1 : home;
                const awayTeam = away === teamCount - 1 ? teamCount - 1 : away;

                matches.push({
                    teamAId: teams[homeTeam].id,
                    teamBId: teams[awayTeam].id,
                    roundNumber: Math.floor(round / 2) + 1,
                    format: 'BO3'
                });
            }
        }

        return matches;
    }

    // 季后赛对阵生成
    generatePlayoffsBracket(teams: Team[]): PlayoffsBracket {
        // 排序获取前4名
        const topTeams = teams.slice(0, 4);

        return {
            winnersGroup: [
                { teamA: topTeams[0], teamB: topTeams[1] }
            ],
            losersGroup: [
                { teamA: topTeams[2], teamB: topTeams[3] }
            ]
        };
    }

    // MSI赛制生成
    generateMSIBracket(teams: Team[]): MSIBracket {
        const legends = teams.filter(t => t.seedType === 'champion');
        const challengers = teams.filter(t => t.seedType === 'runner_up');
        const qualifiers = teams.filter(t => t.seedType === 'third_place');

        return {
            qualifierRound: this.generateQualifierMatches(qualifiers),
            challengerRound: this.generateChallengerMatches(challengers),
            mainTournament: this.generateDoubleEliminationBracket([...legends])
        };
    }

    // 洲际赛四阶段生成
    generateIntercontinentalBracket(teams: Team[]): IntercontinentalBracket {
        const legends = teams.slice(0, 4);
        const challengers = teams.slice(4, 8);
        const fighters = teams.slice(8, 16);

        return {
            stage1: this.generateFighterGroups(fighters),
            stage2: this.generateChallengerMatches(challengers),
            stage3: this.generateDoubleEliminationBracket([]),
            stage4: this.generateFinalStageBracket(legends)
        };
    }
}
```

#### 3.3.2 积分计算引擎
```typescript
// 积分计算引擎
class ScoringEngine {
    private rules: Map<string, ScoringRule> = new Map();

    constructor() {
        this.initializeScoringRules();
    }

    // 初始化积分规则
    private initializeScoringRules(): void {
        // 联赛积分规则
        this.rules.set('league_match', {
            '2-0': 3,
            '2-1': 2,
            '1-2': 1,
            '0-2': 0
        });

        // 季后赛积分规则
        this.rules.set('league_playoffs', {
            'champion': 12,
            'runner_up': 10,
            'third_place': 8,
            'fourth_place': 6
        });

        // MSI积分规则
        this.rules.set('msi', {
            'champion': 20,
            'runner_up': 16,
            'third_place': 12,
            'fourth_place': 8,
            'quarter_finalist': 6,
            'group_stage': 4
        });

        // 洲际赛积分规则
        this.rules.set('intercontinental', {
            'champion': 35,
            'runner_up': 30,
            'third_place': 25,
            'fourth_place': 20,
            'stage4_semifinal': 15,
            'stage4_quarterfinal': 10,
            'stage3_eliminated': 8,
            'stage2_eliminated': 5,
            'stage1_eliminated': 2
        });
    }

    // 计算比赛积分
    async calculateMatchScore(match: Match): Promise<ScoreCalculation> {
        const competitionType = await this.getCompetitionType(match.competitionId);
        const rule = this.rules.get(competitionType);

        if (!rule) {
            throw new Error(`No scoring rule found for competition type: ${competitionType}`);
        }

        const scoreKey = `${match.scoreA}-${match.scoreB}`;
        const winnerPoints = rule[scoreKey] || 0;
        const loserPoints = rule[`${match.scoreB}-${match.scoreA}`] || 0;

        return {
            winnerId: match.winnerId,
            winnerPoints,
            loserId: match.winnerId === match.teamAId ? match.teamBId : match.teamAId,
            loserPoints
        };
    }

    // 计算年度积分排名
    async calculateSeasonRanking(seasonYear: number): Promise<TeamRanking[]> {
        const query = `
            SELECT
                t.id,
                t.name,
                t.region_id,
                SUM(sr.points) as total_points,
                COUNT(DISTINCT sr.competition_id) as competitions_played
            FROM teams t
            LEFT JOIN score_records sr ON t.id = sr.team_id AND sr.season_year = $1
            GROUP BY t.id, t.name, t.region_id
            ORDER BY total_points DESC
        `;

        const result = await this.db.query(query, [seasonYear]);
        return result.rows;
    }

    // 计算跨年度积分（洲际赛用）
    async calculateIntercontinentalRanking(year1: number, year2: number): Promise<TeamRanking[]> {
        const query = `
            SELECT
                t.id,
                t.name,
                t.region_id,
                SUM(sr.points) as total_points
            FROM teams t
            LEFT JOIN score_records sr ON t.id = sr.team_id
            WHERE sr.season_year IN ($1, $2)
            GROUP BY t.id, t.name, t.region_id
            ORDER BY total_points DESC
            LIMIT 16
        `;

        const result = await this.db.query(query, [year1, year2]);
        return result.rows;
    }
}
```

### 3.3 抽签服务

#### 3.3.1 抽签算法引擎
```typescript
// 抽签引擎
class DrawEngine {
    // 随机抽签核心算法
    private shuffleArray<T>(array: T[]): T[] {
        const shuffled = [...array];
        for (let i = shuffled.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        return shuffled;
    }

    // Fighter组分组抽签
    async drawFighterGroups(teams: Team[]): Promise<FighterGroupDraw> {
        if (teams.length !== 8) {
            throw new Error('Fighter groups require exactly 8 teams');
        }

        const shuffledTeams = this.shuffleArray(teams);

        return {
            groupA: shuffledTeams.slice(0, 4),
            groupB: shuffledTeams.slice(4, 8),
            drawTimestamp: new Date(),
            seed: Math.random().toString(36).substring(7)
        };
    }

    // 挑战者组定位赛抽签
    async drawChallengerMatches(teams: Team[]): Promise<ChallengerDraw> {
        if (teams.length !== 4) {
            throw new Error('Challenger draw requires exactly 4 teams');
        }

        const shuffledTeams = this.shuffleArray(teams);

        return {
            match1: { teamA: shuffledTeams[0], teamB: shuffledTeams[1] },
            match2: { teamA: shuffledTeams[2], teamB: shuffledTeams[3] },
            drawTimestamp: new Date(),
            seed: Math.random().toString(36).substring(7)
        };
    }

    // 洲际赛第四阶段抽签（避开同赛区）
    async drawFinalStage(legends: Team[], qualifiers: Team[]): Promise<FinalStageDraw> {
        const availableMatchups = this.generateAvailableMatchups(legends, qualifiers);
        const selectedMatchups = this.selectOptimalMatchups(availableMatchups);

        return {
            matchups: selectedMatchups,
            drawTimestamp: new Date(),
            constraints: {
                avoidSameRegion: true,
                seedProtection: true
            }
        };
    }

    // 生成可用对阵组合（避开同赛区）
    private generateAvailableMatchups(legends: Team[], qualifiers: Team[]): Matchup[] {
        const matchups: Matchup[] = [];

        for (const legend of legends) {
            for (const qualifier of qualifiers) {
                if (legend.regionId !== qualifier.regionId) {
                    matchups.push({
                        teamA: legend,
                        teamB: qualifier,
                        regionConflict: false
                    });
                }
            }
        }

        return matchups;
    }

    // 选择最优对阵组合
    private selectOptimalMatchups(availableMatchups: Matchup[]): Matchup[] {
        // 使用回溯算法找到无冲突的完整对阵组合
        const usedTeams = new Set<string>();
        const selectedMatchups: Matchup[] = [];

        for (const matchup of this.shuffleArray(availableMatchups)) {
            if (!usedTeams.has(matchup.teamA.id) && !usedTeams.has(matchup.teamB.id)) {
                selectedMatchups.push(matchup);
                usedTeams.add(matchup.teamA.id);
                usedTeams.add(matchup.teamB.id);
            }
        }

        return selectedMatchups;
    }

    // 保存抽签记录
    async saveDrawRecord(competitionId: string, phase: string, drawData: any): Promise<void> {
        const query = `
            INSERT INTO draw_records (competition_id, phase, draw_data)
            VALUES ($1, $2, $3)
        `;
        await this.db.query(query, [competitionId, phase, JSON.stringify(drawData)]);
    }
}
```

### 3.4 统计分析服务

#### 3.4.1 数据聚合与分析
```typescript
// 统计分析服务
class StatisticsService {
    // 战队历史交锋分析
    async getTeamHeadToHead(teamAId: string, teamBId: string): Promise<HeadToHeadStats> {
        const query = `
            SELECT
                m.*,
                c.type as competition_type,
                c.name as competition_name,
                s.year as season_year
            FROM matches m
            JOIN competitions c ON m.competition_id = c.id
            JOIN seasons s ON c.season_id = s.id
            WHERE (m.team_a_id = $1 AND m.team_b_id = $2)
               OR (m.team_a_id = $2 AND m.team_b_id = $1)
            ORDER BY m.completed_at DESC
        `;

        const result = await this.db.query(query, [teamAId, teamBId]);
        const matches = result.rows;

        return {
            totalMatches: matches.length,
            teamAWins: matches.filter(m => m.winner_id === teamAId).length,
            teamBWins: matches.filter(m => m.winner_id === teamBId).length,
            recentMatches: matches.slice(0, 10),
            competitionBreakdown: this.groupMatchesByCompetition(matches),
            winRateTrend: this.calculateWinRateTrend(matches, teamAId)
        };
    }

    // 赛区实力分析
    async getRegionAnalysis(): Promise<RegionAnalysis[]> {
        const query = `
            SELECT
                r.id,
                r.name,
                COUNT(t.id) as team_count,
                AVG(t.power_rating) as avg_power_rating,
                SUM(t.total_wins) as total_wins,
                SUM(t.total_matches) as total_matches,
                AVG(CASE WHEN t.total_matches > 0 THEN t.total_wins::float / t.total_matches ELSE 0 END) as avg_win_rate
            FROM regions r
            LEFT JOIN teams t ON r.id = t.region_id
            GROUP BY r.id, r.name
            ORDER BY avg_power_rating DESC
        `;

        const result = await this.db.query(query);
        return result.rows;
    }

    // 积分趋势分析
    async getPointsTrend(teamId: string, seasonYear: number): Promise<PointsTrend> {
        const query = `
            SELECT
                sr.*,
                c.type as competition_type,
                c.name as competition_name,
                m.completed_at
            FROM score_records sr
            JOIN competitions c ON sr.competition_id = c.id
            LEFT JOIN matches m ON sr.match_id = m.id
            WHERE sr.team_id = $1 AND sr.season_year = $2
            ORDER BY sr.created_at ASC
        `;

        const result = await this.db.query(query, [teamId, seasonYear]);
        const records = result.rows;

        let cumulativePoints = 0;
        const trendData = records.map(record => {
            cumulativePoints += record.points;
            return {
                date: record.created_at,
                points: record.points,
                cumulativePoints,
                competitionType: record.competition_type,
                competitionName: record.competition_name
            };
        });

        return {
            teamId,
            seasonYear,
            totalPoints: cumulativePoints,
            trendData,
            milestones: this.identifyMilestones(trendData)
        };
    }

    // 性能指标分析
    async getPerformanceMetrics(): Promise<PerformanceMetrics> {
        const queries = await Promise.all([
            this.getTopPerformers(),
            this.getCompetitionWinners(),
            this.getRegionDominance(),
            this.getUpsetMatches()
        ]);

        return {
            topPerformers: queries[0],
            competitionWinners: queries[1],
            regionDominance: queries[2],
            upsetMatches: queries[3],
            generatedAt: new Date()
        };
    }

    // 预测模型（基于历史数据）
    async generateMatchPrediction(teamAId: string, teamBId: string): Promise<MatchPrediction> {
        const [teamAStats, teamBStats, headToHead] = await Promise.all([
            this.getTeamStatistics(teamAId),
            this.getTeamStatistics(teamBId),
            this.getTeamHeadToHead(teamAId, teamBId)
        ]);

        // 简化的预测算法
        const powerRatingDiff = teamAStats.powerRating - teamBStats.powerRating;
        const formDiff = teamAStats.recentForm - teamBStats.recentForm;
        const headToHeadFactor = headToHead.teamAWins / (headToHead.totalMatches || 1);

        const teamAWinProbability = this.calculateWinProbability(
            powerRatingDiff,
            formDiff,
            headToHeadFactor
        );

        return {
            teamAWinProbability,
            teamBWinProbability: 1 - teamAWinProbability,
            confidence: this.calculateConfidence(headToHead.totalMatches),
            factors: {
                powerRating: powerRatingDiff,
                recentForm: formDiff,
                headToHead: headToHeadFactor
            }
        };
    }
}
```

## 四、API接口设计

### 4.1 RESTful API规范

#### 4.1.1 核心接口设计 - 需求适配更新 🆕

**重要变更说明**：
基于甲方需求变更，API接口设计进行了重大调整，从手动创建导向转为自动生成导向。

```typescript
// 赛事管理接口 - 更新版本
interface CompetitionAPI {
    'GET    /api/competitions'             // 获取赛事列表
    'GET    /api/competitions/:id'         // 获取赛事详情
    // 'POST   /api/competitions'          // 创建赛事 【已移除】
    'PUT    /api/competitions/:id/status'  // 更新赛事状态【新增】
    'POST   /api/competitions/auto-generate' // 触发自动生成【新增】
    'GET    /api/competitions/:id/banner-data' // 获取横幅展示数据【新增】
    'GET    /api/competitions/:id/bracket' // 获取对阵图
    'POST   /api/competitions/:id/draw'    // 执行抽签
    'GET    /api/competitions/:id/standings'  // 获取积分榜
    'GET    /api/competitions/:id/champions'  // 获取冠军信息【新增】
}

// 自动赛事生成接口 【全新模块】
interface AutoTournamentAPI {
    'GET    /api/auto-tournament/rules'           // 获取自动生成规则
    'PUT    /api/auto-tournament/rules/:id'       // 更新生成规则
    'POST   /api/auto-tournament/check'           // 手动检查触发条件
    'POST   /api/auto-tournament/execute/:ruleId' // 执行特定规则
    'GET    /api/auto-tournament/logs'            // 获取执行日志
    'POST   /api/auto-tournament/preview'         // 预览生成结果
}

// 横幅数据接口 【新增模块】
interface BannerAPI {
    'GET    /api/banners/competitions'            // 获取赛事横幅数据
    'GET    /api/banners/competitions/:type'      // 按类型获取横幅
    'GET    /api/banners/champions-wall'          // 获取冠军墙数据
    'GET    /api/banners/timeline/:year'          // 获取年度时间线数据
}

// 荣誉殿堂接口 【全新模块】🆕
interface HonorHallAPI {
    'GET    /api/honor-hall/seasons'              // 获取可用赛季列表
    'GET    /api/honor-hall/season/:id'           // 获取指定赛季荣誉数据
    'GET    /api/honor-hall/regional/:seasonId'   // 获取赛区赛荣誉
    'GET    /api/honor-hall/global/:seasonId'     // 获取全球赛荣誉
    'GET    /api/honor-hall/rankings/:seasonId'   // 获取年度积分排名
    'GET    /api/honor-hall/achievements/:teamId' // 获取队伍历史成就
    'GET    /api/honor-hall/statistics/:seasonId' // 获取赛季统计数据
    'GET    /api/honor-hall/records/all'          // 获取历史记录汇总
}
```

**接口设计原则调整**：
- **移除创建类接口**：所有赛事创建通过自动生成机制
- **增强查询接口**：支持横幅展示所需的聚合数据
- **新增监听接口**：支持前端实时获取自动生成结果
- **优化数据结构**：针对可视化展示优化返回格式

// 赛程管理接口
interface ScheduleAPI {
    'GET    /api/schedule/:competitionId'           // 获取赛程状态
    'GET    /api/schedule/:competitionId/round/:round'  // 获取指定轮次信息
    'POST   /api/schedule/:competitionId/next-round'    // 推进到下一轮
    'POST   /api/schedule/:competitionId/simulate-round' // 模拟当前轮次
    'GET    /api/schedule/:competitionId/scoreboard'    // 获取积分榜
    'GET    /api/schedule/:competitionId/remaining'     // 获取剩余赛程
}

// 比赛管理接口
interface MatchAPI {
    'GET    /api/matches'                  // 获取比赛列表
    'GET    /api/matches/:id'              // 获取比赛详情
    'PUT    /api/matches/:id/result'       // 更新比赛结果
    'POST   /api/matches/:id/simulate'     // 模拟比赛结果
    'GET    /api/matches/upcoming'         // 即将进行的比赛
    'GET    /api/matches/recent'           // 最近完成的比赛
}

// 统计分析接口
interface StatisticsAPI {
    'GET    /api/statistics/rankings'      // 获取排名
    'GET    /api/statistics/region-analysis'  // 赛区分析
    'GET    /api/statistics/performance-metrics'  // 性能指标
    'GET    /api/statistics/trends/:teamId'   // 积分趋势
    'POST   /api/statistics/predict-match'    // 比赛预测
}
```

#### 4.1.2 请求响应格式
```typescript
// 统一响应格式
interface APIResponse<T> {
    success: boolean;
    data?: T;
    error?: {
        code: string;
        message: string;
        details?: any;
    };
    meta?: {
        pagination?: {
            page: number;
            limit: number;
            total: number;
            totalPages: number;
        };
        timestamp: string;
        requestId: string;
    };
}

// 分页请求参数
interface PaginationParams {
    page?: number;
    limit?: number;
    sortBy?: string;
    sortOrder?: 'asc' | 'desc';
    filter?: Record<string, any>;
}

// 错误码定义
enum ErrorCodes {
    TEAM_NOT_FOUND = 'TEAM_NOT_FOUND',
    COMPETITION_NOT_ACTIVE = 'COMPETITION_NOT_ACTIVE',
    INVALID_MATCH_RESULT = 'INVALID_MATCH_RESULT',
    DRAW_ALREADY_COMPLETED = 'DRAW_ALREADY_COMPLETED',
    INSUFFICIENT_TEAMS = 'INSUFFICIENT_TEAMS',
    ROUND_NOT_READY = 'ROUND_NOT_READY',
    SIMULATION_FAILED = 'SIMULATION_FAILED',
    INVALID_ROUND_NUMBER = 'INVALID_ROUND_NUMBER'
}
```

### 4.2 GraphQL Schema设计

#### 4.2.1 核心类型定义
```graphql
# 战队类型
type Team {
    id: ID!
    name: String!
    region: Region!
    powerRating: Int!
    foundedDate: Date
    statistics: TeamStatistics!
    matches(limit: Int): [Match!]!
    scores(seasonYear: Int): [ScoreRecord!]!
}

# 赛事类型
type Competition {
    id: ID!
    name: String!
    type: CompetitionType!
    season: Season!
    status: CompetitionStatus!
    format: CompetitionFormat!
    teams: [Team!]!
    matches: [Match!]!
    bracket: Bracket
    standings: [Standing!]!
}

# 赛程类型
type Schedule {
    id: ID!
    competition: Competition!
    currentRound: Int!
    totalRounds: Int!
    rounds: [Round!]!
    scoreboard: [TeamScore!]!
    status: ScheduleStatus!
    lastUpdated: DateTime!
}

# 轮次类型
type Round {
    number: Int!
    status: RoundStatus!
    matches: [Match!]!
    startDate: DateTime
    endDate: DateTime
    isSimulated: Boolean!
}

# 队伍积分类型
type TeamScore {
    team: Team!
    points: Int!
    matches: Int!
    wins: Int!
    losses: Int!
    ranking: Int!
}

# 比赛类型
type Match {
    id: ID!
    competition: Competition!
    teamA: Team!
    teamB: Team!
    scoreA: Int!
    scoreB: Int!
    winner: Team
    status: MatchStatus!
    scheduledAt: DateTime
    completedAt: DateTime
    format: MatchFormat!
}

# 查询入口
type Query {
    # 战队查询
    team(id: ID!): Team
    teams(filter: TeamFilter, pagination: Pagination): TeamsConnection!

    # 赛事查询
    competition(id: ID!): Competition
    competitions(filter: CompetitionFilter): [Competition!]!

    # 赛程查询
    schedule(competitionId: ID!): Schedule
    scheduleRound(competitionId: ID!, round: Int!): Round
    scoreboard(competitionId: ID!): [TeamScore!]!

    # 统计查询
    rankings(seasonYear: Int, type: RankingType): [Ranking!]!
    statistics(teamId: ID, competitionId: ID): Statistics!

    # 实时数据
    liveMatches: [Match!]!
    upcomingMatches(limit: Int): [Match!]!
}

# 变更操作
type Mutation {
    # 战队操作
    createTeam(input: CreateTeamInput!): Team!
    updateTeam(id: ID!, input: UpdateTeamInput!): Team!

    # 比赛操作
    updateMatchResult(id: ID!, result: MatchResultInput!): Match!
    simulateMatch(id: ID!): Match!

    # 赛程操作
    proceedToNextRound(competitionId: ID!): RoundResult!
    simulateRound(competitionId: ID!, round: Int!): SimulationResult!

    # 赛事操作
    generateSchedule(competitionId: ID!): Competition!
    executeDraw(competitionId: ID!, phase: String!): DrawResult!
}

# 订阅（实时更新）
type Subscription {
    matchUpdated(competitionId: ID): Match!
    roundCompleted(competitionId: ID!): RoundResult!
    scoreboardUpdated(competitionId: ID!): [TeamScore!]!
    rankingsUpdated(seasonYear: Int): [Ranking!]!
    drawExecuted(competitionId: ID!): DrawResult!
}
```

## 五、技术开发规划

### 5.1 开发阶段规划

#### 阶段一：基础架构搭建（7天）
**任务清单**：
1. **项目初始化**（2天）：
   - Node.js + TypeScript项目搭建
   - Express.js框架配置
   - ESLint + Prettier代码规范
   - 项目目录结构设计
   - Docker容器化配置

2. **数据库设计**（3天）：
   - PostgreSQL数据库设计
   - 表结构创建与索引优化
   - 数据库连接池配置
   - 迁移脚本编写
   - 种子数据准备

3. **基础服务框架**（2天）：
   - 依赖注入容器配置
   - 日志系统集成
   - 错误处理中间件
   - 配置管理系统
   - 健康检查端点

#### 阶段二：核心业务服务开发（18天）
**任务清单**：
1. **战队管理服务**（3天）：
   - TeamService业务逻辑
   - TeamRepository数据访问
   - 战队CRUD接口
   - 战队统计计算
   - 缓存策略实现

2. **赛程管理服务**（6天）：
   - ScheduleService核心逻辑
   - 战力模拟引擎开发
   - 下一轮推进算法
   - 积分更新机制
   - 实时状态同步

3. **赛事管理服务**（5天）：
   - CompetitionService核心逻辑
   - 赛制引擎开发
   - 赛程生成算法
   - 对阵图数据结构
   - 赛事状态管理

4. **比赛管理服务**（4天）：
   - MatchService业务逻辑
   - 胜负判定算法
   - 比赛结果验证
   - 实时更新机制
   - 模拟功能实现

#### 阶段三：高级功能开发（10天）
**任务清单**：
1. **积分计算服务**（4天）：
   - ScoringEngine核心算法
   - 积分规则配置化
   - 排名计算逻辑
   - 跨年度积分汇总
   - 数据一致性保证

2. **抽签系统**（3天）：
   - DrawEngine抽签算法
   - 随机性保证机制
   - 规则约束处理
   - 抽签历史记录
   - 可视化数据准备

2. **统计分析服务**（3天）：
   - StatisticsService分析逻辑
   - 数据聚合算法
   - 趋势分析计算
   - 预测模型实现
   - 性能指标统计

3. **GraphQL接口**（2天）：
   - Schema设计实现
   - Resolver函数编写
   - 实时订阅功能
   - 查询优化
   - 数据加载器

#### 阶段四：系统集成与优化（8天）
**任务清单**：
1. **缓存系统**（2天）：
   - Redis缓存策略
   - 缓存失效机制
   - 分布式缓存
   - 性能监控

2. **消息队列**（2天）：
   - 异步任务处理
   - 事件驱动架构
   - 消息可靠性保证
   - 失败重试机制

3. **性能优化**（2天）：
   - 数据库查询优化
   - API响应时间优化
   - 内存使用优化
   - 并发处理优化

4. **安全加固**（2天）：
   - 输入验证加强
   - SQL注入防护
   - 请求频率限制
   - 数据加密处理

#### 阶段五：测试与部署（5天）
**任务清单**：
1. **测试体系**（3天）：
   - 单元测试编写
   - 集成测试实现
   - API接口测试
   - 性能压力测试
   - 测试覆盖率分析

2. **部署准备**（2天）：
   - 生产环境配置
   - CI/CD流水线
   - 监控告警系统
   - 备份恢复方案
   - 文档编写

### 5.2 技术风险控制

#### 5.2.1 性能风险
**风险点**：
- 复杂积分计算导致响应延迟
- 大量并发请求数据库压力
- 实时更新频繁影响系统稳定性

**应对措施**：
- 异步任务处理重计算逻辑
- 数据库读写分离和分片
- 缓存热点数据减少数据库访问
- 限流和熔断机制

#### 5.2.2 数据一致性风险
**风险点**：
- 积分计算错误导致排名异常
- 并发更新导致数据冲突
- 分布式事务一致性问题

**应对措施**：
- 数据库事务确保原子性
- 乐观锁处理并发冲突
- 事件溯源记录所有变更
- 定期数据校验机制

#### 5.2.3 扩展性风险
**风险点**：
- 单体架构扩展困难
- 数据库成为性能瓶颈
- 业务逻辑耦合度高

**应对措施**：
- 微服务架构预留扩展空间
- 数据库分库分表策略
- 领域驱动设计降低耦合
- 服务化拆分方案

## 六、监控与运维

### 6.1 监控体系

#### 6.1.1 应用监控
```typescript
// 性能监控中间件
class PerformanceMonitor {
    collectMetrics(req: Request, res: Response, next: NextFunction) {
        const startTime = Date.now();

        res.on('finish', () => {
            const duration = Date.now() - startTime;

            // 记录响应时间
            this.metricsCollector.recordResponseTime(
                req.route?.path,
                req.method,
                res.statusCode,
                duration
            );

            // 记录错误率
            if (res.statusCode >= 400) {
                this.metricsCollector.recordError(
                    req.route?.path,
                    req.method,
                    res.statusCode
                );
            }
        });

        next();
    }
}

// 业务指标监控
class BusinessMetrics {
    async recordMatchResult(match: Match) {
        await this.metricsCollector.increment('matches.completed');
        await this.metricsCollector.gauge('matches.average_duration', match.duration);
    }

    async recordUserActivity(userId: string, action: string) {
        await this.metricsCollector.increment(`user.${action}`);
        await this.metricsCollector.set('users.active', userId);
    }
}
```

#### 6.1.2 告警配置
```yaml
# 告警规则配置
alerts:
  - name: high_response_time
    condition: avg(response_time) > 1000ms
    duration: 5m
    actions:
      - email: tech-team@company.com
      - slack: #alerts

  - name: high_error_rate
    condition: error_rate > 5%
    duration: 2m
    actions:
      - email: tech-team@company.com
      - pager: on-call-engineer

  - name: database_connection_pool_exhausted
    condition: db_pool_usage > 90%
    duration: 1m
    actions:
      - email: dba-team@company.com
      - auto_scale: database_pool
```

### 6.2 日志管理

#### 6.2.1 日志标准化
```typescript
// 结构化日志
class Logger {
    private winston: Winston.Logger;

    constructor() {
        this.winston = winston.createLogger({
            format: winston.format.combine(
                winston.format.timestamp(),
                winston.format.errors({ stack: true }),
                winston.format.json()
            ),
            transports: [
                new winston.transports.File({ filename: 'app.log' }),
                new winston.transports.Console({
                    format: winston.format.simple()
                })
            ]
        });
    }

    logBusinessEvent(event: BusinessEvent) {
        this.winston.info('Business Event', {
            eventType: event.type,
            entityId: event.entityId,
            entityType: event.entityType,
            userId: event.userId,
            timestamp: event.timestamp,
            metadata: event.metadata
        });
    }

    logAPIRequest(req: Request, res: Response, duration: number) {
        this.winston.info('API Request', {
            method: req.method,
            url: req.url,
            statusCode: res.statusCode,
            duration,
            userAgent: req.get('User-Agent'),
            ip: req.ip
        });
    }
}
```

## 七、安全与数据保护

### 7.1 安全策略

#### 7.1.1 认证授权
```typescript
// JWT认证中间件
class AuthenticationMiddleware {
    async authenticate(req: Request, res: Response, next: NextFunction) {
        try {
            const token = this.extractToken(req);
            if (!token) {
                return res.status(401).json({ error: 'No token provided' });
            }

            const payload = jwt.verify(token, process.env.JWT_SECRET!);
            req.user = await this.userService.getUserById(payload.sub);
            next();
        } catch (error) {
            return res.status(401).json({ error: 'Invalid token' });
        }
    }

    authorize(roles: string[]) {
        return (req: Request, res: Response, next: NextFunction) => {
            if (!req.user || !roles.includes(req.user.role)) {
                return res.status(403).json({ error: 'Insufficient permissions' });
            }
            next();
        };
    }
}
```

#### 7.1.2 输入验证
```typescript
// 数据验证中间件
class ValidationMiddleware {
    static validateTeamCreation = [
        body('name').isLength({ min: 1, max: 100 }).trim().escape(),
        body('regionId').isUUID(),
        body('powerRating').isInt({ min: 0, max: 100 }),
        body('foundedDate').optional().isISO8601(),

        (req: Request, res: Response, next: NextFunction) => {
            const errors = validationResult(req);
            if (!errors.isEmpty()) {
                return res.status(400).json({
                    error: 'Validation failed',
                    details: errors.array()
                });
            }
            next();
        }
    ];
}
```

### 7.2 数据备份与恢复

#### 7.2.1 备份策略
```bash
#!/bin/bash
# 数据库备份脚本

DB_NAME="esports_simulator"
BACKUP_DIR="/var/backups/postgresql"
DATE=$(date +%Y%m%d_%H%M%S)

# 全量备份
pg_dump -h localhost -U postgres -d $DB_NAME -f $BACKUP_DIR/full_backup_$DATE.sql

# 增量备份
pg_basebackup -h localhost -U postgres -D $BACKUP_DIR/incremental_$DATE -Ft -z

# 清理旧备份
find $BACKUP_DIR -name "*.sql" -mtime +7 -delete
find $BACKUP_DIR -name "incremental_*" -mtime +3 -delete
```

## 八、技术方案总结

### 8.1 架构优势
1. **微服务准备**：模块化设计支持后续服务拆分
2. **高性能**：缓存策略和数据库优化确保响应速度
3. **可扩展**：插件化赛制引擎支持新赛制扩展
4. **可靠性**：完善的错误处理和监控机制

### 8.2 核心特性
1. **复杂赛制支持**：四阶段洲际赛等复杂赛制完整实现
2. **实时计算**：积分排名实时更新，数据一致性保证
3. **智能抽签**：约束条件下的随机抽签算法
4. **数据分析**：丰富的统计分析和趋势预测

### 8.3 技术创新点
1. **算法优化**：高效的赛程生成和积分计算算法
2. **缓存策略**：多层次缓存提升系统性能
3. **事件驱动**：基于事件的异步处理机制
4. **数据可视化**：为前端提供丰富的可视化数据支持

本技术方案为电竞赛事模拟系统后端提供了完整的技术架构和实现路径，确保系统的高性能、高可用和可扩展性，满足复杂业务需求。