// =================================================================
// 电竞赛事模拟系统 - 赛制引擎
// =================================================================

import { Team, Match, MatchFormat, CompetitionFormat } from '../types';
import { logger } from '../utils/logger';

export interface MatchGenerationOptions {
  competitionId: string;
  phase: string;
  format: MatchFormat;
  startDate?: Date;
}

export interface PlayoffsBracket {
  winnersGroup: { teamA: Team; teamB: Team }[];
  losersGroup: { teamA: Team; teamB: Team }[];
}

export interface MSIBracket {
  qualifierRound: Match[];
  challengerRound: Match[];
  mainTournament: Match[];
}

export interface IntercontinentalBracket {
  stage1: { groupA: Team[]; groupB: Team[] };
  stage2: Match[];
  stage3: Match[];
  stage4: Match[];
}

export class CompetitionEngine {
  // 生成常规赛赛程（双循环）
  // 算法说明：使用循环赛算法（Round-robin tournament）
  // 10支队伍，每两队交战2次（主客场），共90场比赛，分18轮
  generateRegularSeasonSchedule(teams: Team[], options: MatchGenerationOptions): Match[] {
    const matches: Match[] = [];
    const teamCount = teams.length;

    if (teamCount < 2) {
      throw new Error('At least 2 teams required for regular season');
    }

    // 如果是奇数队伍，添加一个轮空（bye）
    const isOdd = teamCount % 2 !== 0;
    const n = isOdd ? teamCount + 1 : teamCount;

    // 创建队伍数组副本
    const teamsList = [...teams];
    if (isOdd) {
      teamsList.push(null as any); // null 表示轮空
    }

    // 双循环：第一循环和第二循环
    for (let cycle = 0; cycle < 2; cycle++) {
      // 每个循环有 n-1 轮（对于n支队伍）
      for (let round = 0; round < n - 1; round++) {
        const currentRound = cycle * (n - 1) + round + 1;

        // 每轮有 n/2 场比赛
        for (let match = 0; match < n / 2; match++) {
          let home = (round + match) % (n - 1);
          let away = (n - 1 - match + round) % (n - 1);

          // 最后一个位置固定不动（循环赛算法特点）
          if (match === 0) {
            away = n - 1;
          }

          // 跳过轮空队伍
          if (home >= teamCount || away >= teamCount) {
            continue;
          }

          // 第二循环交换主客场
          const homeTeam = cycle === 0 ? teamsList[home] : teamsList[away];
          const awayTeam = cycle === 0 ? teamsList[away] : teamsList[home];

          // 确保不是同一支队伍对战
          if (homeTeam && awayTeam && homeTeam.id !== awayTeam.id) {
            matches.push({
              id: '', // Will be generated by database
              competitionId: options.competitionId,
              teamAId: homeTeam.id,
              teamBId: awayTeam.id,
              scoreA: 0,
              scoreB: 0,
              format: options.format,
              phase: options.phase,
              roundNumber: currentRound,
              matchNumber: matches.length + 1,
              status: 'scheduled' as any,
              scheduledAt: this.calculateMatchDate(options.startDate, currentRound - 1),
              createdAt: new Date(),
              updatedAt: new Date()
            } as Match);
          }
        }
      }
    }

    logger.info('Regular season schedule generated:', {
      competitionId: options.competitionId,
      teamsCount: teamCount,
      totalRounds: (n - 1) * 2,
      matchesCount: matches.length,
      expectedMatches: teamCount * (teamCount - 1) // 双循环：每队对战其他所有队伍2次
    });

    return matches;
  }

  // 生成季后赛对阵
  generatePlayoffsBracket(teams: Team[], options: MatchGenerationOptions): Match[] {
    if (teams.length < 4) {
      throw new Error('At least 4 teams required for playoffs');
    }

    // 按排名排序（假设已经按积分排序）
    const topTeams = teams.slice(0, 4);
    const matches: Match[] = [];

    // 上半区: 1 vs 4, 2 vs 3
    matches.push({
      id: '',
      competitionId: options.competitionId,
      teamAId: topTeams[0].id, // 第1名
      teamBId: topTeams[3].id, // 第4名
      scoreA: 0,
      scoreB: 0,
      format: options.format,
      phase: 'semifinals',
      roundNumber: 1,
      matchNumber: 1,
      status: 'scheduled',
      scheduledAt: this.calculateMatchDate(options.startDate, 0),
      createdAt: new Date(),
      updatedAt: new Date()
    } as Match);

    matches.push({
      id: '',
      competitionId: options.competitionId,
      teamAId: topTeams[1].id, // 第2名
      teamBId: topTeams[2].id, // 第3名
      scoreA: 0,
      scoreB: 0,
      format: options.format,
      phase: 'semifinals',
      roundNumber: 1,
      matchNumber: 2,
      status: 'scheduled',
      scheduledAt: this.calculateMatchDate(options.startDate, 1),
      createdAt: new Date(),
      updatedAt: new Date()
    } as Match);

    // 决赛
    matches.push({
      id: '',
      competitionId: options.competitionId,
      teamAId: '', // 待定 - 半决赛1获胜者
      teamBId: '', // 待定 - 半决赛2获胜者
      scoreA: 0,
      scoreB: 0,
      format: MatchFormat.BO5,
      phase: 'finals',
      roundNumber: 2,
      matchNumber: 3,
      status: 'scheduled',
      scheduledAt: this.calculateMatchDate(options.startDate, 7), // 一周后
      createdAt: new Date(),
      updatedAt: new Date()
    } as Match);

    logger.info('Playoffs bracket generated:', {
      competitionId: options.competitionId,
      teamsCount: topTeams.length,
      matchesCount: matches.length
    });

    return matches;
  }

  // 生成MSI赛制
  generateMSIBracket(teams: Team[], options: MatchGenerationOptions): Match[] {
    const matches: Match[] = [];

    // 分组队伍
    const legends = teams.filter(team => this.getTeamSeedType(team) === 'legend').slice(0, 4);
    const challengers = teams.filter(team => this.getTeamSeedType(team) === 'challenger').slice(0, 4);
    const qualifiers = teams.filter(team => this.getTeamSeedType(team) === 'qualifier').slice(0, 4);

    let matchNumber = 1;

    // 第一阶段：资格赛（4队伍，2队晋级）
    if (qualifiers.length >= 4) {
      for (let i = 0; i < qualifiers.length; i += 2) {
        matches.push({
          id: '',
          competitionId: options.competitionId,
          teamAId: qualifiers[i].id,
          teamBId: qualifiers[i + 1].id,
          scoreA: 0,
          scoreB: 0,
          format: MatchFormat.BO1,
          phase: 'qualifier',
          roundNumber: 1,
          matchNumber: matchNumber++,
          status: 'scheduled' as any,
          scheduledAt: this.calculateMatchDate(options.startDate, matches.length),
          createdAt: new Date(),
          updatedAt: new Date()
        } as Match);
      }
    }

    // 第二阶段：挑战者赛（4+2队伍，2队晋级）
    if (challengers.length >= 4) {
      for (let i = 0; i < challengers.length; i += 2) {
        matches.push({
          id: '',
          competitionId: options.competitionId,
          teamAId: challengers[i].id,
          teamBId: challengers[i + 1].id,
          scoreA: 0,
          scoreB: 0,
          format: MatchFormat.BO3,
          phase: 'challenger',
          roundNumber: 1,
          matchNumber: matchNumber++,
          status: 'scheduled' as any,
          scheduledAt: this.calculateMatchDate(options.startDate, matches.length + 3),
          createdAt: new Date(),
          updatedAt: new Date()
        } as Match);
      }
    }

    // 第三阶段：主赛事（传奇组4队 + 晋级的4队）
    if (legends.length >= 4) {
      // 半决赛
      matches.push({
        id: '',
        competitionId: options.competitionId,
        teamAId: legends[0].id,
        teamBId: '', // 挑战者组晋级队伍
        scoreA: 0,
        scoreB: 0,
        format: MatchFormat.BO5,
        phase: 'semifinals',
        roundNumber: 1,
        matchNumber: matchNumber++,
        status: 'scheduled',
        scheduledAt: this.calculateMatchDate(options.startDate, matches.length + 7),
        createdAt: new Date(),
        updatedAt: new Date()
      } as Match);

      matches.push({
        id: '',
        competitionId: options.competitionId,
        teamAId: legends[1].id,
        teamBId: '', // 挑战者组晋级队伍
        scoreA: 0,
        scoreB: 0,
        format: MatchFormat.BO5,
        phase: 'semifinals',
        roundNumber: 1,
        matchNumber: matchNumber++,
        status: 'scheduled',
        scheduledAt: this.calculateMatchDate(options.startDate, matches.length + 7),
        createdAt: new Date(),
        updatedAt: new Date()
      } as Match);

      // 决赛
      matches.push({
        id: '',
        competitionId: options.competitionId,
        teamAId: '', // 半决赛1获胜者
        teamBId: '', // 半决赛2获胜者
        scoreA: 0,
        scoreB: 0,
        format: MatchFormat.BO5,
        phase: 'finals',
        roundNumber: 2,
        matchNumber: matchNumber++,
        status: 'scheduled',
        scheduledAt: this.calculateMatchDate(options.startDate, matches.length + 10),
        createdAt: new Date(),
        updatedAt: new Date()
      } as Match);
    }

    logger.info('MSI bracket generated:', {
      competitionId: options.competitionId,
      legendsCount: legends.length,
      challengersCount: challengers.length,
      qualifiersCount: qualifiers.length,
      matchesCount: matches.length
    });

    return matches;
  }

  // 生成洲际赛四阶段赛制
  generateIntercontinentalBracket(teams: Team[], options: MatchGenerationOptions): Match[] {
    const matches: Match[] = [];

    // 分组队伍（按积分排序）
    const legends = teams.slice(0, 4);      // 前4名
    const challengers = teams.slice(4, 8);  // 5-8名
    const fighters = teams.slice(8, 16);    // 9-16名

    let matchNumber = 1;

    // 第一阶段：争夺者组（8队分2组，每组4队）
    const fighterGroupA = fighters.slice(0, 4);
    const fighterGroupB = fighters.slice(4, 8);

    // A组循环赛
    for (let i = 0; i < fighterGroupA.length; i++) {
      for (let j = i + 1; j < fighterGroupA.length; j++) {
        matches.push({
          id: '',
          competitionId: options.competitionId,
          teamAId: fighterGroupA[i].id,
          teamBId: fighterGroupA[j].id,
          scoreA: 0,
          scoreB: 0,
          format: MatchFormat.BO1,
          phase: 'stage1_group_a',
          roundNumber: 1,
          matchNumber: matchNumber++,
          status: 'scheduled' as any,
          scheduledAt: this.calculateMatchDate(options.startDate, matches.length),
          createdAt: new Date(),
          updatedAt: new Date()
        } as Match);
      }
    }

    // B组循环赛
    for (let i = 0; i < fighterGroupB.length; i++) {
      for (let j = i + 1; j < fighterGroupB.length; j++) {
        matches.push({
          id: '',
          competitionId: options.competitionId,
          teamAId: fighterGroupB[i].id,
          teamBId: fighterGroupB[j].id,
          scoreA: 0,
          scoreB: 0,
          format: MatchFormat.BO1,
          phase: 'stage1_group_b',
          roundNumber: 1,
          matchNumber: matchNumber++,
          status: 'scheduled' as any,
          scheduledAt: this.calculateMatchDate(options.startDate, matches.length),
          createdAt: new Date(),
          updatedAt: new Date()
        } as Match);
      }
    }

    // 第二阶段：挑战者组定位赛（4队 + 争夺者组前2）
    for (let i = 0; i < challengers.length; i += 2) {
      matches.push({
        id: '',
        competitionId: options.competitionId,
        teamAId: challengers[i].id,
        teamBId: challengers[i + 1].id,
        scoreA: 0,
        scoreB: 0,
        format: MatchFormat.BO3,
        phase: 'stage2_challenger',
        roundNumber: 1,
        matchNumber: matchNumber++,
        status: 'scheduled',
        scheduledAt: this.calculateMatchDate(options.startDate, matches.length + 7),
        createdAt: new Date(),
        updatedAt: new Date()
      } as Match);
    }

    // 第三阶段：双败淘汰赛
    // 这里简化处理，实际应该生成完整的双败bracket
    matches.push({
      id: '',
      competitionId: options.competitionId,
      teamAId: '', // 挑战者组获胜者
      teamBId: '', // 挑战者组获胜者
      scoreA: 0,
      scoreB: 0,
      format: MatchFormat.BO5,
      phase: 'stage3_elimination',
      roundNumber: 1,
      matchNumber: matchNumber++,
      status: 'scheduled',
      scheduledAt: this.calculateMatchDate(options.startDate, matches.length + 14),
      createdAt: new Date(),
      updatedAt: new Date()
    } as Match);

    // 第四阶段：传奇组对阵（传奇组4队 vs 第三阶段晋级队伍）
    for (let i = 0; i < legends.length; i++) {
      matches.push({
        id: '',
        competitionId: options.competitionId,
        teamAId: legends[i].id,
        teamBId: '', // 第三阶段晋级队伍
        scoreA: 0,
        scoreB: 0,
        format: MatchFormat.BO5,
        phase: 'stage4_legends',
        roundNumber: 1,
        matchNumber: matchNumber++,
        status: 'scheduled',
        scheduledAt: this.calculateMatchDate(options.startDate, matches.length + 21),
        createdAt: new Date(),
        updatedAt: new Date()
      } as Match);
    }

    // 最终决赛
    matches.push({
      id: '',
      competitionId: options.competitionId,
      teamAId: '', // 第四阶段获胜者
      teamBId: '', // 第四阶段获胜者
      scoreA: 0,
      scoreB: 0,
      format: MatchFormat.BO5,
      phase: 'finals',
      roundNumber: 2,
      matchNumber: matchNumber++,
      status: 'scheduled',
      scheduledAt: this.calculateMatchDate(options.startDate, matches.length + 28),
      createdAt: new Date(),
      updatedAt: new Date()
    } as Match);

    logger.info('Intercontinental bracket generated:', {
      competitionId: options.competitionId,
      legendsCount: legends.length,
      challengersCount: challengers.length,
      fightersCount: fighters.length,
      matchesCount: matches.length
    });

    return matches;
  }

  // 根据赛制配置生成对应的赛程
  generateScheduleByFormat(
    format: CompetitionFormat,
    teams: Team[],
    options: MatchGenerationOptions
  ): Match[] {
    switch (format.type) {
      case 'league':
        return this.generateRegularSeasonSchedule(teams, {
          ...options,
          format: (format.regularSeason?.matchFormat || MatchFormat.BO3) as MatchFormat
        });

      case 'playoff':
        return this.generatePlayoffsBracket(teams, {
          ...options,
          format: (format.playoffs?.matchFormat || MatchFormat.BO5) as MatchFormat
        });

      case 'msi':
        return this.generateMSIBracket(teams, options);

      case 'intercontinental':
        return this.generateIntercontinentalBracket(teams, options);

      default:
        throw new Error(`Unsupported competition format: ${format.type}`);
    }
  }

  // 计算比赛日期
  private calculateMatchDate(startDate?: Date, dayOffset: number = 0): Date {
    const baseDate = startDate || new Date();
    const matchDate = new Date(baseDate);
    matchDate.setDate(matchDate.getDate() + dayOffset);
    return matchDate;
  }

  // 获取队伍种子类型（用于MSI等赛制）
  private getTeamSeedType(team: Team): 'legend' | 'challenger' | 'qualifier' {
    // 这里可以根据战队的积分或排名来判断种子类型
    // 暂时根据战力值简单判断
    if (team.powerRating >= 85) {
      return 'legend';
    } else if (team.powerRating >= 75) {
      return 'challenger';
    } else {
      return 'qualifier';
    }
  }
}