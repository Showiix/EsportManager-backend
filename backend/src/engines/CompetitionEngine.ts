// =================================================================
// 电竞赛事模拟系统 - 赛制引擎
// =================================================================

import { Team, Match, MatchFormat, CompetitionFormat } from '../types';
import { logger } from '../utils/logger';

export interface MatchGenerationOptions {
  competitionId: string;
  phase: string;
  format: MatchFormat;
  startDate?: Date;
}

export interface PlayoffsBracket {
  winnersGroup: { teamA: Team; teamB: Team }[];
  losersGroup: { teamA: Team; teamB: Team }[];
}

export interface MSIBracket {
  qualifierRound: Match[];
  challengerRound: Match[];
  mainTournament: Match[];
}

export interface IntercontinentalBracket {
  stage1: { groupA: Team[]; groupB: Team[] };
  stage2: Match[];
  stage3: Match[];
  stage4: Match[];
}

export class CompetitionEngine {
  // 生成常规赛赛程（双循环）
  generateRegularSeasonSchedule(teams: Team[], options: MatchGenerationOptions): Match[] {
    const matches: Match[] = [];
    const teamCount = teams.length;

    if (teamCount < 2) {
      throw new Error('At least 2 teams required for regular season');
    }

    // 双循环赛程算法
    for (let round = 0; round < (teamCount - 1) * 2; round++) {
      for (let match = 0; match < Math.floor(teamCount / 2); match++) {
        const home = (round + match) % (teamCount - 1);
        const away = (teamCount - 1 - match + round) % (teamCount - 1);

        // 处理最后一个队伍
        const homeTeamIndex = home === teamCount - 1 ? teamCount - 1 : home;
        const awayTeamIndex = away === teamCount - 1 ? teamCount - 1 : away;

        if (homeTeamIndex !== awayTeamIndex) {
          matches.push({
            id: '', // Will be generated by database
            competitionId: options.competitionId,
            teamAId: teams[homeTeamIndex].id,
            teamBId: teams[awayTeamIndex].id,
            scoreA: 0,
            scoreB: 0,
            format: options.format,
            phase: options.phase,
            roundNumber: Math.floor(round / 2) + 1,
            matchNumber: matches.length + 1,
            status: 'scheduled' as any,
            scheduledAt: this.calculateMatchDate(options.startDate, matches.length),
            createdAt: new Date(),
            updatedAt: new Date()
          } as Match);
        }
      }
    }

    logger.info('Regular season schedule generated:', {
      competitionId: options.competitionId,
      teamsCount: teamCount,
      matchesCount: matches.length
    });

    return matches;
  }

  // 生成季后赛对阵
  generatePlayoffsBracket(teams: Team[], options: MatchGenerationOptions): Match[] {
    if (teams.length < 4) {
      throw new Error('At least 4 teams required for playoffs');
    }

    // 按排名排序（假设已经按积分排序）
    const topTeams = teams.slice(0, 4);
    const matches: Match[] = [];

    // 上半区: 1 vs 4, 2 vs 3
    matches.push({
      id: '',
      competitionId: options.competitionId,
      teamAId: topTeams[0].id, // 第1名
      teamBId: topTeams[3].id, // 第4名
      scoreA: 0,
      scoreB: 0,
      format: options.format,
      phase: 'semifinals',
      roundNumber: 1,
      matchNumber: 1,
      status: 'scheduled',
      scheduledAt: this.calculateMatchDate(options.startDate, 0),
      createdAt: new Date(),
      updatedAt: new Date()
    } as Match);

    matches.push({
      id: '',
      competitionId: options.competitionId,
      teamAId: topTeams[1].id, // 第2名
      teamBId: topTeams[2].id, // 第3名
      scoreA: 0,
      scoreB: 0,
      format: options.format,
      phase: 'semifinals',
      roundNumber: 1,
      matchNumber: 2,
      status: 'scheduled',
      scheduledAt: this.calculateMatchDate(options.startDate, 1),
      createdAt: new Date(),
      updatedAt: new Date()
    } as Match);

    // 决赛
    matches.push({
      id: '',
      competitionId: options.competitionId,
      teamAId: '', // 待定 - 半决赛1获胜者
      teamBId: '', // 待定 - 半决赛2获胜者
      scoreA: 0,
      scoreB: 0,
      format: MatchFormat.BO5,
      phase: 'finals',
      roundNumber: 2,
      matchNumber: 3,
      status: 'scheduled',
      scheduledAt: this.calculateMatchDate(options.startDate, 7), // 一周后
      createdAt: new Date(),
      updatedAt: new Date()
    } as Match);

    logger.info('Playoffs bracket generated:', {
      competitionId: options.competitionId,
      teamsCount: topTeams.length,
      matchesCount: matches.length
    });

    return matches;
  }

  // 生成MSI赛制
  generateMSIBracket(teams: Team[], options: MatchGenerationOptions): Match[] {
    const matches: Match[] = [];

    // 分组队伍
    const legends = teams.filter(team => this.getTeamSeedType(team) === 'legend').slice(0, 4);
    const challengers = teams.filter(team => this.getTeamSeedType(team) === 'challenger').slice(0, 4);
    const qualifiers = teams.filter(team => this.getTeamSeedType(team) === 'qualifier').slice(0, 4);

    let matchNumber = 1;

    // 第一阶段：资格赛（4队伍，2队晋级）
    if (qualifiers.length >= 4) {
      for (let i = 0; i < qualifiers.length; i += 2) {
        matches.push({
          id: '',
          competitionId: options.competitionId,
          teamAId: qualifiers[i].id,
          teamBId: qualifiers[i + 1].id,
          scoreA: 0,
          scoreB: 0,
          format: MatchFormat.BO1,
          phase: 'qualifier',
          roundNumber: 1,
          matchNumber: matchNumber++,
          status: 'scheduled' as any,
          scheduledAt: this.calculateMatchDate(options.startDate, matches.length),
          createdAt: new Date(),
          updatedAt: new Date()
        } as Match);
      }
    }

    // 第二阶段：挑战者赛（4+2队伍，2队晋级）
    if (challengers.length >= 4) {
      for (let i = 0; i < challengers.length; i += 2) {
        matches.push({
          id: '',
          competitionId: options.competitionId,
          teamAId: challengers[i].id,
          teamBId: challengers[i + 1].id,
          scoreA: 0,
          scoreB: 0,
          format: MatchFormat.BO3,
          phase: 'challenger',
          roundNumber: 1,
          matchNumber: matchNumber++,
          status: 'scheduled' as any,
          scheduledAt: this.calculateMatchDate(options.startDate, matches.length + 3),
          createdAt: new Date(),
          updatedAt: new Date()
        } as Match);
      }
    }

    // 第三阶段：主赛事（传奇组4队 + 晋级的4队）
    if (legends.length >= 4) {
      // 半决赛
      matches.push({
        id: '',
        competitionId: options.competitionId,
        teamAId: legends[0].id,
        teamBId: '', // 挑战者组晋级队伍
        scoreA: 0,
        scoreB: 0,
        format: MatchFormat.BO5,
        phase: 'semifinals',
        roundNumber: 1,
        matchNumber: matchNumber++,
        status: 'scheduled',
        scheduledAt: this.calculateMatchDate(options.startDate, matches.length + 7),
        createdAt: new Date(),
        updatedAt: new Date()
      } as Match);

      matches.push({
        id: '',
        competitionId: options.competitionId,
        teamAId: legends[1].id,
        teamBId: '', // 挑战者组晋级队伍
        scoreA: 0,
        scoreB: 0,
        format: MatchFormat.BO5,
        phase: 'semifinals',
        roundNumber: 1,
        matchNumber: matchNumber++,
        status: 'scheduled',
        scheduledAt: this.calculateMatchDate(options.startDate, matches.length + 7),
        createdAt: new Date(),
        updatedAt: new Date()
      } as Match);

      // 决赛
      matches.push({
        id: '',
        competitionId: options.competitionId,
        teamAId: '', // 半决赛1获胜者
        teamBId: '', // 半决赛2获胜者
        scoreA: 0,
        scoreB: 0,
        format: MatchFormat.BO5,
        phase: 'finals',
        roundNumber: 2,
        matchNumber: matchNumber++,
        status: 'scheduled',
        scheduledAt: this.calculateMatchDate(options.startDate, matches.length + 10),
        createdAt: new Date(),
        updatedAt: new Date()
      } as Match);
    }

    logger.info('MSI bracket generated:', {
      competitionId: options.competitionId,
      legendsCount: legends.length,
      challengersCount: challengers.length,
      qualifiersCount: qualifiers.length,
      matchesCount: matches.length
    });

    return matches;
  }

  // 生成洲际赛四阶段赛制
  generateIntercontinentalBracket(teams: Team[], options: MatchGenerationOptions): Match[] {
    const matches: Match[] = [];

    // 分组队伍（按积分排序）
    const legends = teams.slice(0, 4);      // 前4名
    const challengers = teams.slice(4, 8);  // 5-8名
    const fighters = teams.slice(8, 16);    // 9-16名

    let matchNumber = 1;

    // 第一阶段：争夺者组（8队分2组，每组4队）
    const fighterGroupA = fighters.slice(0, 4);
    const fighterGroupB = fighters.slice(4, 8);

    // A组循环赛
    for (let i = 0; i < fighterGroupA.length; i++) {
      for (let j = i + 1; j < fighterGroupA.length; j++) {
        matches.push({
          id: '',
          competitionId: options.competitionId,
          teamAId: fighterGroupA[i].id,
          teamBId: fighterGroupA[j].id,
          scoreA: 0,
          scoreB: 0,
          format: MatchFormat.BO1,
          phase: 'stage1_group_a',
          roundNumber: 1,
          matchNumber: matchNumber++,
          status: 'scheduled' as any,
          scheduledAt: this.calculateMatchDate(options.startDate, matches.length),
          createdAt: new Date(),
          updatedAt: new Date()
        } as Match);
      }
    }

    // B组循环赛
    for (let i = 0; i < fighterGroupB.length; i++) {
      for (let j = i + 1; j < fighterGroupB.length; j++) {
        matches.push({
          id: '',
          competitionId: options.competitionId,
          teamAId: fighterGroupB[i].id,
          teamBId: fighterGroupB[j].id,
          scoreA: 0,
          scoreB: 0,
          format: MatchFormat.BO1,
          phase: 'stage1_group_b',
          roundNumber: 1,
          matchNumber: matchNumber++,
          status: 'scheduled' as any,
          scheduledAt: this.calculateMatchDate(options.startDate, matches.length),
          createdAt: new Date(),
          updatedAt: new Date()
        } as Match);
      }
    }

    // 第二阶段：挑战者组定位赛（4队 + 争夺者组前2）
    for (let i = 0; i < challengers.length; i += 2) {
      matches.push({
        id: '',
        competitionId: options.competitionId,
        teamAId: challengers[i].id,
        teamBId: challengers[i + 1].id,
        scoreA: 0,
        scoreB: 0,
        format: MatchFormat.BO3,
        phase: 'stage2_challenger',
        roundNumber: 1,
        matchNumber: matchNumber++,
        status: 'scheduled',
        scheduledAt: this.calculateMatchDate(options.startDate, matches.length + 7),
        createdAt: new Date(),
        updatedAt: new Date()
      } as Match);
    }

    // 第三阶段：双败淘汰赛
    // 这里简化处理，实际应该生成完整的双败bracket
    matches.push({
      id: '',
      competitionId: options.competitionId,
      teamAId: '', // 挑战者组获胜者
      teamBId: '', // 挑战者组获胜者
      scoreA: 0,
      scoreB: 0,
      format: MatchFormat.BO5,
      phase: 'stage3_elimination',
      roundNumber: 1,
      matchNumber: matchNumber++,
      status: 'scheduled',
      scheduledAt: this.calculateMatchDate(options.startDate, matches.length + 14),
      createdAt: new Date(),
      updatedAt: new Date()
    } as Match);

    // 第四阶段：传奇组对阵（传奇组4队 vs 第三阶段晋级队伍）
    for (let i = 0; i < legends.length; i++) {
      matches.push({
        id: '',
        competitionId: options.competitionId,
        teamAId: legends[i].id,
        teamBId: '', // 第三阶段晋级队伍
        scoreA: 0,
        scoreB: 0,
        format: MatchFormat.BO5,
        phase: 'stage4_legends',
        roundNumber: 1,
        matchNumber: matchNumber++,
        status: 'scheduled',
        scheduledAt: this.calculateMatchDate(options.startDate, matches.length + 21),
        createdAt: new Date(),
        updatedAt: new Date()
      } as Match);
    }

    // 最终决赛
    matches.push({
      id: '',
      competitionId: options.competitionId,
      teamAId: '', // 第四阶段获胜者
      teamBId: '', // 第四阶段获胜者
      scoreA: 0,
      scoreB: 0,
      format: MatchFormat.BO5,
      phase: 'finals',
      roundNumber: 2,
      matchNumber: matchNumber++,
      status: 'scheduled',
      scheduledAt: this.calculateMatchDate(options.startDate, matches.length + 28),
      createdAt: new Date(),
      updatedAt: new Date()
    } as Match);

    logger.info('Intercontinental bracket generated:', {
      competitionId: options.competitionId,
      legendsCount: legends.length,
      challengersCount: challengers.length,
      fightersCount: fighters.length,
      matchesCount: matches.length
    });

    return matches;
  }

  // 根据赛制配置生成对应的赛程
  generateScheduleByFormat(
    format: CompetitionFormat,
    teams: Team[],
    options: MatchGenerationOptions
  ): Match[] {
    switch (format.type) {
      case 'league':
        return this.generateRegularSeasonSchedule(teams, {
          ...options,
          format: (format.regularSeason?.matchFormat || MatchFormat.BO3) as MatchFormat
        });

      case 'playoff':
        return this.generatePlayoffsBracket(teams, {
          ...options,
          format: (format.playoffs?.matchFormat || MatchFormat.BO5) as MatchFormat
        });

      case 'msi':
        return this.generateMSIBracket(teams, options);

      case 'intercontinental':
        return this.generateIntercontinentalBracket(teams, options);

      default:
        throw new Error(`Unsupported competition format: ${format.type}`);
    }
  }

  // 计算比赛日期
  private calculateMatchDate(startDate?: Date, dayOffset: number = 0): Date {
    const baseDate = startDate || new Date();
    const matchDate = new Date(baseDate);
    matchDate.setDate(matchDate.getDate() + dayOffset);
    return matchDate;
  }

  // 获取队伍种子类型（用于MSI等赛制）
  private getTeamSeedType(team: Team): 'legend' | 'challenger' | 'qualifier' {
    // 这里可以根据战队的积分或排名来判断种子类型
    // 暂时根据战力值简单判断
    if (team.powerRating >= 85) {
      return 'legend';
    } else if (team.powerRating >= 75) {
      return 'challenger';
    } else {
      return 'qualifier';
    }
  }
}