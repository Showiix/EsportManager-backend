// =================================================================
// 电竞赛事模拟系统 - 积分计算引擎
// =================================================================

import { databaseService } from '../services/DatabaseService';
import {
  Match,
  Competition,
  ScoreRecord,
  ScoringRules,
  Ranking
} from '../types';
import { logger } from '../utils/logger';

export interface ScoreCalculation {
  winnerId: string;
  winnerPoints: number;
  loserId: string;
  loserPoints: number;
  pointType: string;
}

export interface TournamentPlacement {
  teamId: string;
  placement: string;
  points: number;
}

export class ScoringEngine {
  private rules: Map<string, ScoringRules> = new Map();

  constructor() {
    this.initializeScoringRules();
  }

  // 初始化积分规则
  private initializeScoringRules(): void {
    // 联赛积分规则
    this.rules.set('spring', {
      regular: {
        'win_2_0': 3,
        'win_2_1': 2,
        'loss_1_2': 1,
        'loss_0_2': 0
      },
      playoffs: {
        'champion': 12,
        'runner_up': 10,
        'third_place': 8,
        'fourth_place': 6
      }
    });

    this.rules.set('summer', {
      regular: {
        'win_2_0': 3,
        'win_2_1': 2,
        'loss_1_2': 1,
        'loss_0_2': 0
      },
      playoffs: {
        'champion': 12,
        'runner_up': 10,
        'third_place': 8,
        'fourth_place': 6
      }
    });

    // MSI积分规则
    this.rules.set('msi', {
      groupStage: {
        'win': 2,
        'loss': 0
      },
      knockout: {
        'champion': 20,
        'runner_up': 16,
        'third_place': 12,
        'fourth_place': 8,
        'quarter_finalist': 6,
        'group_stage_exit': 4
      }
    });

    // 世界赛积分规则
    this.rules.set('worlds', {
      groupStage: {
        'win': 2,
        'loss': 0
      },
      knockout: {
        'champion': 35,
        'runner_up': 30,
        'third_place': 25,
        'fourth_place': 20,
        'quarter_finalist': 15,
        'group_stage_exit': 10
      }
    });
  }

  // 计算比赛积分
  async calculateMatchScore(match: Match, competition: Competition): Promise<ScoreCalculation> {
    try {
      const competitionType = competition.type;
      const rules = this.rules.get(competitionType) || competition.scoringRules;

      if (!rules) {
        throw new Error(`No scoring rules found for competition type: ${competitionType}`);
      }

      // 根据比赛阶段获取规则
      const phaseRules = this.getPhaseRules(rules, match.phase);

      if (!phaseRules) {
        throw new Error(`No scoring rules found for phase: ${match.phase}`);
      }

      // 计算积分
      const scoreKey = `${match.scoreA}_${match.scoreB}`;
      const reverseScoreKey = `${match.scoreB}_${match.scoreA}`;

      let winnerPoints = 0;
      let loserPoints = 0;

      // 根据比分确定积分
      if (match.format === 'BO3') {
        winnerPoints = phaseRules[`win_${scoreKey}`] || phaseRules['win'] || 0;
        loserPoints = phaseRules[`loss_${reverseScoreKey}`] || phaseRules['loss'] || 0;
      } else if (match.format === 'BO1') {
        winnerPoints = phaseRules['win'] || 1;
        loserPoints = phaseRules['loss'] || 0;
      } else {
        // BO5或其他格式
        winnerPoints = phaseRules['win'] || 3;
        loserPoints = phaseRules['loss'] || 0;
      }

      const loserId = match.winnerId === match.teamAId ? match.teamBId : match.teamAId;

      return {
        winnerId: match.winnerId!,
        winnerPoints,
        loserId,
        loserPoints,
        pointType: `${competitionType}_${match.phase}`
      };
    } catch (error) {
      logger.error('Failed to calculate match score:', { matchId: match.id, error });
      throw error;
    }
  }

  // 计算锦标赛排名积分
  async calculateTournamentPlacementScores(
    competitionId: string,
    placements: TournamentPlacement[]
  ): Promise<ScoreRecord[]> {
    try {
      const competition = await this.getCompetitionById(competitionId);
      const rules = this.rules.get(competition.type) || competition.scoringRules;

      if (!rules || !rules.playoffs) {
        throw new Error(`No tournament placement rules found for competition: ${competitionId}`);
      }

      const scoreRecords: ScoreRecord[] = [];
      const seasonYear = await this.getSeasonYear(competitionId);

      for (const placement of placements) {
        const points = rules.playoffs[placement.placement] || 0;

        if (points > 0) {
          scoreRecords.push({
            id: '', // Will be generated by database
            teamId: placement.teamId,
            competitionId,
            points,
            pointType: `${competition.type}_${placement.placement}`,
            seasonYear,
            earnedAt: new Date(),
            description: `${competition.type} tournament ${placement.placement}`,
            createdAt: new Date()
          });
        }
      }

      logger.info('Tournament placement scores calculated:', {
        competitionId,
        placementsCount: placements.length,
        scoresCount: scoreRecords.length
      });

      return scoreRecords;
    } catch (error) {
      logger.error('Failed to calculate tournament placement scores:', { competitionId, error });
      throw error;
    }
  }

  // 计算年度积分排名
  async calculateSeasonRanking(seasonYear: number): Promise<Ranking[]> {
    try {
      const query = `
        SELECT
          t.id as team_id,
          t.name as team_name,
          t.short_name,
          r.name as region_name,
          r.code as region_code,
          COALESCE(SUM(sr.points), 0) as total_points,
          COALESCE(SUM(CASE WHEN c.type = 'spring' THEN sr.points ELSE 0 END), 0) as spring_points,
          COALESCE(SUM(CASE WHEN c.type = 'msi' THEN sr.points ELSE 0 END), 0) as msi_points,
          COALESCE(SUM(CASE WHEN c.type = 'summer' THEN sr.points ELSE 0 END), 0) as summer_points,
          COALESCE(SUM(CASE WHEN c.type = 'worlds' THEN sr.points ELSE 0 END), 0) as worlds_points,
          COUNT(DISTINCT sr.competition_id) as competitions_played,
          t.total_wins as wins,
          t.total_losses as losses,
          t.total_matches as matches_played,
          CASE
            WHEN t.total_matches > 0 THEN ROUND((t.total_wins::DECIMAL / t.total_matches) * 100, 2)
            ELSE 0.00
          END as win_rate
        FROM teams t
        JOIN regions r ON t.region_id = r.id
        LEFT JOIN score_records sr ON t.id = sr.team_id AND sr.season_year = $1
        LEFT JOIN competitions c ON sr.competition_id = c.id
        WHERE t.is_active = true
        GROUP BY t.id, t.name, t.short_name, r.name, r.code, t.total_wins, t.total_losses, t.total_matches
        ORDER BY total_points DESC, wins DESC, win_rate DESC
      `;

      const result = await databaseService.query(query, [seasonYear]);

      const rankings: Ranking[] = result.rows.map((row, index) => ({
        teamId: row.team_id,
        teamName: row.team_name,
        shortName: row.short_name,
        regionName: row.region_name,
        regionCode: row.region_code,
        seasonYear,
        totalPoints: parseInt(row.total_points),
        springPoints: parseInt(row.spring_points),
        msiPoints: parseInt(row.msi_points),
        summerPoints: parseInt(row.summer_points),
        worldsPoints: parseInt(row.worlds_points),
        ranking: index + 1,
        matchesPlayed: parseInt(row.matches_played),
        wins: parseInt(row.wins),
        losses: parseInt(row.losses),
        winRate: parseFloat(row.win_rate)
      }));

      logger.info('Season ranking calculated:', {
        seasonYear,
        teamsCount: rankings.length
      });

      return rankings;
    } catch (error) {
      logger.error('Failed to calculate season ranking:', { seasonYear, error });
      throw error;
    }
  }

  // 计算跨年度积分（用于洲际赛资格）
  async calculateIntercontinentalRanking(year1: number, year2: number): Promise<Ranking[]> {
    try {
      const query = `
        SELECT
          t.id as team_id,
          t.name as team_name,
          t.short_name,
          r.name as region_name,
          r.code as region_code,
          COALESCE(SUM(sr.points), 0) as total_points
        FROM teams t
        JOIN regions r ON t.region_id = r.id
        LEFT JOIN score_records sr ON t.id = sr.team_id
        WHERE t.is_active = true AND sr.season_year IN ($1, $2)
        GROUP BY t.id, t.name, t.short_name, r.name, r.code
        ORDER BY total_points DESC
        LIMIT 16
      `;

      const result = await databaseService.query(query, [year1, year2]);

      const rankings: Ranking[] = result.rows.map((row, index) => ({
        teamId: row.team_id,
        teamName: row.team_name,
        shortName: row.short_name,
        regionName: row.region_name,
        regionCode: row.region_code,
        seasonYear: year2, // 使用最新年份
        totalPoints: parseInt(row.total_points),
        springPoints: 0,
        msiPoints: 0,
        summerPoints: 0,
        worldsPoints: 0,
        ranking: index + 1,
        matchesPlayed: 0,
        wins: 0,
        losses: 0,
        winRate: 0
      }));

      logger.info('Intercontinental ranking calculated:', {
        year1,
        year2,
        qualifiedTeams: rankings.length
      });

      return rankings;
    } catch (error) {
      logger.error('Failed to calculate intercontinental ranking:', { year1, year2, error });
      throw error;
    }
  }

  // 保存积分记录
  async saveScoreRecord(scoreRecord: Omit<ScoreRecord, 'id' | 'createdAt'>): Promise<ScoreRecord> {
    try {
      const query = `
        INSERT INTO score_records (
          team_id, competition_id, match_id, points, point_type,
          season_year, earned_at, description
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
        RETURNING *
      `;

      const result = await databaseService.query(query, [
        scoreRecord.teamId,
        scoreRecord.competitionId,
        scoreRecord.matchId,
        scoreRecord.points,
        scoreRecord.pointType,
        scoreRecord.seasonYear,
        scoreRecord.earnedAt,
        scoreRecord.description
      ]);

      logger.info('Score record saved:', {
        teamId: scoreRecord.teamId,
        points: scoreRecord.points,
        pointType: scoreRecord.pointType
      });

      return result.rows[0];
    } catch (error) {
      logger.error('Failed to save score record:', error);
      throw error;
    }
  }

  // 批量保存积分记录
  async saveScoreRecords(scoreRecords: Omit<ScoreRecord, 'id' | 'createdAt'>[]): Promise<ScoreRecord[]> {
    if (scoreRecords.length === 0) {
      return [];
    }

    try {
      const values = scoreRecords.map((_, index) => {
        const baseIndex = index * 8;
        return `($${baseIndex + 1}, $${baseIndex + 2}, $${baseIndex + 3}, $${baseIndex + 4}, $${baseIndex + 5}, $${baseIndex + 6}, $${baseIndex + 7}, $${baseIndex + 8})`;
      }).join(', ');

      const query = `
        INSERT INTO score_records (
          team_id, competition_id, match_id, points, point_type,
          season_year, earned_at, description
        )
        VALUES ${values}
        RETURNING *
      `;

      const params = scoreRecords.flatMap(record => [
        record.teamId,
        record.competitionId,
        record.matchId,
        record.points,
        record.pointType,
        record.seasonYear,
        record.earnedAt,
        record.description
      ]);

      const result = await databaseService.query(query, params);

      logger.info('Score records saved:', { count: result.rows.length });

      return result.rows;
    } catch (error) {
      logger.error('Failed to save score records:', error);
      throw error;
    }
  }

  // 更新战队统计数据
  async updateTeamStatistics(teamId: string, seasonYear: number): Promise<void> {
    try {
      const query = `
        INSERT INTO team_statistics (
          team_id, season_year, total_points, spring_points, msi_points,
          summer_points, worlds_points, matches_played, wins, losses, win_rate
        )
        SELECT
          $1 as team_id,
          $2 as season_year,
          COALESCE(SUM(sr.points), 0) as total_points,
          COALESCE(SUM(CASE WHEN c.type = 'spring' THEN sr.points ELSE 0 END), 0) as spring_points,
          COALESCE(SUM(CASE WHEN c.type = 'msi' THEN sr.points ELSE 0 END), 0) as msi_points,
          COALESCE(SUM(CASE WHEN c.type = 'summer' THEN sr.points ELSE 0 END), 0) as summer_points,
          COALESCE(SUM(CASE WHEN c.type = 'worlds' THEN sr.points ELSE 0 END), 0) as worlds_points,
          t.total_matches,
          t.total_wins,
          t.total_losses,
          CASE
            WHEN t.total_matches > 0 THEN ROUND((t.total_wins::DECIMAL / t.total_matches) * 100, 2)
            ELSE 0.00
          END as win_rate
        FROM teams t
        LEFT JOIN score_records sr ON t.id = sr.team_id AND sr.season_year = $2
        LEFT JOIN competitions c ON sr.competition_id = c.id
        WHERE t.id = $1
        GROUP BY t.id, t.total_matches, t.total_wins, t.total_losses
        ON CONFLICT (team_id, season_year) DO UPDATE SET
          total_points = EXCLUDED.total_points,
          spring_points = EXCLUDED.spring_points,
          msi_points = EXCLUDED.msi_points,
          summer_points = EXCLUDED.summer_points,
          worlds_points = EXCLUDED.worlds_points,
          matches_played = EXCLUDED.matches_played,
          wins = EXCLUDED.wins,
          losses = EXCLUDED.losses,
          win_rate = EXCLUDED.win_rate,
          last_updated = CURRENT_TIMESTAMP
      `;

      await databaseService.query(query, [teamId, seasonYear]);

      logger.info('Team statistics updated:', { teamId, seasonYear });
    } catch (error) {
      logger.error('Failed to update team statistics:', { teamId, seasonYear, error });
      throw error;
    }
  }

  // 根据阶段获取积分规则
  private getPhaseRules(rules: ScoringRules, phase: string): any {
    if (phase.includes('regular') || phase.includes('group')) {
      return rules.regular || rules.groupStage;
    } else if (phase.includes('playoff') || phase.includes('knockout') || phase.includes('elimination')) {
      return rules.playoffs || rules.knockout;
    }
    return rules.regular; // 默认使用常规赛规则
  }

  // 获取赛事信息
  private async getCompetitionById(competitionId: string): Promise<Competition> {
    const query = `
      SELECT c.*, s.year as season_year
      FROM competitions c
      JOIN seasons s ON c.season_id = s.id
      WHERE c.id = $1
    `;

    const result = await databaseService.query(query, [competitionId]);

    if (result.rows.length === 0) {
      throw new Error(`Competition not found: ${competitionId}`);
    }

    const competition = result.rows[0];

    // 解析JSON字段
    if (competition.scoring_rules) {
      competition.scoringRules = JSON.parse(competition.scoring_rules);
    }

    return competition;
  }

  // 获取赛季年份
  private async getSeasonYear(competitionId: string): Promise<number> {
    const query = `
      SELECT s.year
      FROM competitions c
      JOIN seasons s ON c.season_id = s.id
      WHERE c.id = $1
    `;

    const result = await databaseService.query(query, [competitionId]);

    if (result.rows.length === 0) {
      throw new Error(`Season not found for competition: ${competitionId}`);
    }

    return result.rows[0].year;
  }
}

// 单例导出
export const scoringEngine = new ScoringEngine();