# 电竞赛事模拟系统 - 数据库操作指南

## 📋 目录
1. [环境准备](#1-环境准备)
2. [数据库创建与初始化](#2-数据库创建与初始化)
3. [表结构详解](#3-表结构详解)
4. [数据库操作步骤](#4-数据库操作步骤)
5. [初始数据插入](#5-初始数据插入)
6. [常用查询示例](#6-常用查询示例)
7. [数据库维护](#7-数据库维护)
8. [故障排除](#8-故障排除)

---

## 1. 环境准备

### 1.1 确认数据库服务运行

```bash
# 检查 PostgreSQL 服务状态
docker-compose ps

# 如果数据库未运行，启动服务
docker-compose up postgres redis -d

# 查看数据库服务日志
docker-compose logs postgres
```

### 1.2 连接数据库

```bash
# 方法1: 使用 Docker 容器连接
docker-compose exec postgres psql -U postgres -d esports_simulator

# 方法2: 使用本地 psql 客户端
psql -h localhost -p 5432 -U postgres -d esports_simulator

# 方法3: 使用数据库管理工具 (推荐)
# 访问 http://localhost:8080 (Adminer)
# 或使用 pgAdmin, DBeaver 等工具
```

### 1.3 环境变量确认

检查 `.env` 文件中的数据库配置：

```bash
# 查看当前配置
cat .env | grep DB_

# 应该包含以下配置
DB_HOST=localhost
DB_PORT=5432
DB_USERNAME=postgres
DB_PASSWORD=postgres
DB_NAME=esports_simulator
DB_SSL=false
```

---

## 2. 数据库创建与初始化

### 2.1 创建数据库

```sql
-- 连接到 PostgreSQL 服务器
psql -U postgres

-- 创建数据库
CREATE DATABASE esports_simulator;

-- 切换到新数据库
\c esports_simulator;
```

### 2.2 执行初始化脚本

```bash
# 方法1: 直接执行 SQL 文件
psql -h localhost -p 5432 -U postgres -d esports_simulator -f scripts/init-db.sql

# 方法2: 通过 Docker 容器执行
docker-compose exec postgres psql -U postgres -d esports_simulator -f /docker-entrypoint-initdb.d/init-db.sql

# 方法3: 复制粘贴执行
# 将 init-db.sql 文件内容复制到 psql 命令行中执行
```

### 2.3 验证初始化结果

```sql
-- 检查表是否创建成功
\dt

-- 检查视图
\dv

-- 检查函数
\df

-- 检查索引
\di

-- 查看表结构
\d teams
\d matches
\d score_records
```

---

## 3. 表结构详解

### 3.1 核心业务表

#### 3.1.1 赛区表 (regions)
```sql
-- 作用: 存储赛区信息 (LPL, LCK, LEC, LCS等)
-- 主要字段:
-- - id: 主键
-- - name: 赛区名称
-- - code: 赛区代码
-- - display_order: 显示顺序
```

#### 3.1.2 战队表 (teams)
```sql
-- 作用: 存储战队基本信息和统计数据
-- 主要字段:
-- - id: 主键
-- - name: 战队名称
-- - region_id: 所属赛区
-- - power_rating: 战力值 (0-100)
-- - total_matches: 总比赛场次
-- - total_wins/total_losses: 胜/负场数
-- - net_round_difference: 净胜局数
```

#### 3.1.3 比赛表 (matches)
```sql
-- 作用: 存储具体比赛信息和结果
-- 主要字段:
-- - id: 主键
-- - competition_id: 所属赛事
-- - team_a_id, team_b_id: 对阵双方
-- - score_a, score_b: 比分
-- - winner_id: 获胜方
-- - format: 赛制 (BO1/BO3/BO5)
-- - phase: 阶段 (常规赛/季后赛等)
```

### 3.2 赛事管理表

#### 3.2.1 赛季表 (seasons)
```sql
-- 作用: 管理年度赛季信息
-- 主要字段:
-- - id: 主键
-- - name: 赛季名称 (如 S1, S2)
-- - year: 年份
-- - status: 状态 (planning/active/completed)
-- - current_phase: 当前进行阶段
```

#### 3.2.2 赛事表 (competitions)
```sql
-- 作用: 存储具体赛事信息 (春季赛/MSI/世界赛等)
-- 主要字段:
-- - id: 主键
-- - season_id: 所属赛季
-- - type: 赛事类型 (spring/summer/msi/worlds)
-- - format: 赛制配置 (JSON)
-- - scoring_rules: 积分规则 (JSON)
```

### 3.3 统计分析表

#### 3.3.1 积分记录表 (score_records)
```sql
-- 作用: 记录战队获得的每一分积分
-- 主要字段:
-- - team_id: 战队ID
-- - competition_id: 赛事ID
-- - points: 获得积分
-- - point_type: 积分类型
-- - season_year: 赛季年份
```

#### 3.3.2 战队统计表 (team_statistics)
```sql
-- 作用: 存储战队的聚合统计数据
-- 主要字段:
-- - team_id: 战队ID
-- - season_year: 赛季年份
-- - total_points: 总积分
-- - spring_points, msi_points 等: 各赛事积分
-- - current_ranking: 当前排名
```

---

## 4. 数据库操作步骤

### 4.1 第一步：创建和连接数据库

```bash
# 1. 启动数据库服务
cd /Users/showiix/Documents/EsportManager/backend
docker-compose up postgres redis -d

# 2. 等待服务启动完成 (约10-30秒)
docker-compose logs postgres | grep "ready to accept connections"

# 3. 连接数据库
docker-compose exec postgres psql -U postgres

# 4. 创建数据库 (如果不存在)
CREATE DATABASE esports_simulator;

# 5. 连接到目标数据库
\c esports_simulator;
```

### 4.2 第二步：执行初始化脚本

```bash
# 将初始化脚本复制到容器中
docker cp scripts/init-db.sql esportmanager-backend-postgres-1:/tmp/

# 在容器内执行脚本
docker-compose exec postgres psql -U postgres -d esports_simulator -f /tmp/init-db.sql
```

或者直接在 psql 中执行：

```sql
-- 复制整个 init-db.sql 文件内容，粘贴到 psql 命令行中执行
-- 脚本会自动创建所有表、索引、视图和函数
```

### 4.3 第三步：验证数据库结构

```sql
-- 列出所有表
SELECT table_name FROM information_schema.tables
WHERE table_schema = 'public' AND table_type = 'BASE TABLE';

-- 检查关键表的结构
\d teams
\d matches
\d competitions
\d score_records

-- 查看创建的视图
\dv

-- 验证索引
SELECT indexname, tablename FROM pg_indexes WHERE schemaname = 'public';
```

### 4.4 第四步：创建必要的脚本文件

将 SQL 脚本保存到 `backend/scripts/init-db.sql` 文件中：

```bash
# 创建脚本目录
mkdir -p backend/scripts

# 将初始化脚本保存为文件
# (脚本内容见上面提供的完整 SQL 脚本)
```

---

## 5. 初始数据插入

### 5.1 插入基础赛区数据

```sql
-- 插入四个赛区
INSERT INTO regions (name, code, display_order, description) VALUES
('中国大陆职业联赛', 'LPL', 1, '中国大陆地区顶级电竞职业联赛'),
('韩国冠军联赛', 'LCK', 2, '韩国地区顶级电竞职业联赛'),
('欧洲冠军联赛', 'LEC', 3, '欧洲地区顶级电竞职业联赛'),
('北美冠军联赛', 'LCS', 4, '北美地区顶级电竞职业联赛');
```

### 5.2 插入示例战队数据

```sql
-- 获取赛区ID
WITH region_ids AS (
    SELECT id as lpl_id FROM regions WHERE code = 'LPL'
    UNION ALL
    SELECT id as lck_id FROM regions WHERE code = 'LCK'
    UNION ALL
    SELECT id as lec_id FROM regions WHERE code = 'LEC'
    UNION ALL
    SELECT id as lcs_id FROM regions WHERE code = 'LCS'
)

-- 插入LPL战队 (每个赛区10支队伍)
INSERT INTO teams (name, short_name, region_id, power_rating, founded_date)
SELECT * FROM (VALUES
    ('JD Gaming', 'JDG', (SELECT id FROM regions WHERE code = 'LPL'), 88, '2017-05-20'),
    ('Bilibili Gaming', 'BLG', (SELECT id FROM regions WHERE code = 'LPL'), 85, '2017-12-21'),
    ('Top Esports', 'TES', (SELECT id FROM regions WHERE code = 'LPL'), 82, '2019-11-26'),
    ('Weibo Gaming', 'WBG', (SELECT id FROM regions WHERE code = 'LPL'), 79, '2020-11-26'),
    ('Invictus Gaming', 'IG', (SELECT id FROM regions WHERE code = 'LPL'), 76, '2011-08-02'),
    ('FunPlus Phoenix', 'FPX', (SELECT id FROM regions WHERE code = 'LPL'), 74, '2017-12-21'),
    ('EDward Gaming', 'EDG', (SELECT id FROM regions WHERE code = 'LPL'), 72, '2013-09-13'),
    ('Royal Never Give Up', 'RNG', (SELECT id FROM regions WHERE code = 'LPL'), 70, '2012-05-15'),
    ('LNG Esports', 'LNG', (SELECT id FROM regions WHERE code = 'LPL'), 68, '2019-01-01'),
    ('Ninjas in Pyjamas', 'NIP', (SELECT id FROM regions WHERE code = 'LPL'), 65, '2021-11-26')
) AS t(name, short_name, region_id, power_rating, founded_date);

-- 插入LCK战队
INSERT INTO teams (name, short_name, region_id, power_rating, founded_date)
SELECT * FROM (VALUES
    ('T1', 'T1', (SELECT id FROM regions WHERE code = 'LCK'), 90, '2013-02-21'),
    ('Gen.G', 'GEN', (SELECT id FROM regions WHERE code = 'LCK'), 87, '2017-01-11'),
    ('DRX', 'DRX', (SELECT id FROM regions WHERE code = 'LCK'), 84, '2019-11-18'),
    ('KT Rolster', 'KT', (SELECT id FROM regions WHERE code = 'LCK'), 81, '2012-06-08'),
    ('Hanwha Life Esports', 'HLE', (SELECT id FROM regions WHERE code = 'LCK'), 78, '2016-12-01'),
    ('DWG KIA', 'DK', (SELECT id FROM regions WHERE code = 'LCK'), 75, '2017-02-14'),
    ('Liiv SANDBOX', 'LSB', (SELECT id FROM regions WHERE code = 'LCK'), 72, '2018-11-13'),
    ('Kwangdong Freecs', 'KDF', (SELECT id FROM regions WHERE code = 'LCK'), 69, '2016-11-30'),
    ('Nongshim RedForce', 'NS', (SELECT id FROM regions WHERE code = 'LCK'), 66, '2020-11-17'),
    ('OK Savings Bank BRION', 'BRO', (SELECT id FROM regions WHERE code = 'LCK'), 63, '2021-11-19')
) AS t(name, short_name, region_id, power_rating, founded_date);

-- 继续插入LEC和LCS战队...
-- (为简化示例，这里不完整列出所有40支队伍)
```

### 5.3 创建示例赛季

```sql
-- 创建S1赛季
INSERT INTO seasons (name, year, status, current_phase, start_date, end_date)
VALUES ('S1', 2024, 'active', 'spring_regular', '2024-01-15', '2024-11-15');

-- 获取赛季ID用于后续操作
SELECT id, name FROM seasons WHERE name = 'S1';
```

### 5.4 创建示例春季赛

```sql
-- 创建春季赛事
INSERT INTO competitions (season_id, type, name, format, scoring_rules, max_teams, start_date, end_date)
VALUES (
    (SELECT id FROM seasons WHERE name = 'S1'),
    'spring',
    'S1春季赛',
    '{"type": "league", "regular_season": {"format": "double_round_robin", "match_format": "BO3"}, "playoffs": {"format": "double_elimination", "match_format": "BO5"}}',
    '{"regular": {"win_2_0": 3, "win_2_1": 2, "loss_1_2": 1, "loss_0_2": 0}, "playoffs": {"champion": 12, "runner_up": 10, "third_place": 8, "fourth_place": 6}}',
    40,
    '2024-01-15',
    '2024-04-15'
);
```

---

## 6. 常用查询示例

### 6.1 基础查询

```sql
-- 查看所有战队及其赛区
SELECT t.name, t.short_name, t.power_rating, r.name as region_name
FROM teams t
JOIN regions r ON t.region_id = r.id
ORDER BY r.display_order, t.power_rating DESC;

-- 查看某个赛区的战队
SELECT name, short_name, power_rating, total_wins, total_losses
FROM teams t
JOIN regions r ON t.region_id = r.id
WHERE r.code = 'LPL'
ORDER BY power_rating DESC;

-- 查看进行中的赛事
SELECT s.name as season_name, c.name, c.type, c.status
FROM competitions c
JOIN seasons s ON c.season_id = s.id
WHERE c.status = 'active';
```

### 6.2 比赛和积分查询

```sql
-- 查看最近的比赛结果
SELECT * FROM v_match_results
WHERE status = 'completed'
ORDER BY completed_at DESC
LIMIT 10;

-- 查看战队的历史交锋记录
SELECT
    ta.name as team_a,
    tb.name as team_b,
    hth.total_matches,
    hth.team_a_wins,
    hth.team_b_wins,
    hth.last_match_date
FROM head_to_head_records hth
JOIN teams ta ON hth.team_a_id = ta.id
JOIN teams tb ON hth.team_b_id = tb.id
WHERE ta.name = 'JD Gaming' OR tb.name = 'JD Gaming';

-- 查看积分排行榜
SELECT * FROM v_team_rankings
WHERE season_year = 2024
ORDER BY total_points DESC
LIMIT 20;
```

### 6.3 统计分析查询

```sql
-- 各赛区胜率统计
SELECT
    r.name as region_name,
    COUNT(t.id) as team_count,
    AVG(t.power_rating) as avg_power_rating,
    SUM(t.total_wins) as total_wins,
    SUM(t.total_matches) as total_matches,
    ROUND(SUM(t.total_wins)::DECIMAL / NULLIF(SUM(t.total_matches), 0) * 100, 2) as win_rate
FROM regions r
LEFT JOIN teams t ON r.id = t.region_id
WHERE t.is_active = true
GROUP BY r.id, r.name
ORDER BY win_rate DESC;

-- 查看战队积分分布
SELECT
    team_name,
    region_name,
    total_points,
    spring_points,
    msi_points,
    summer_points,
    worlds_points
FROM v_team_rankings
WHERE season_year = 2024 AND total_points > 0
ORDER BY total_points DESC;
```

---

## 7. 数据库维护

### 7.1 定期维护任务

```sql
-- 更新表统计信息
ANALYZE;

-- 重建索引 (如果需要)
REINDEX DATABASE esports_simulator;

-- 清理无用数据
VACUUM;

-- 查看数据库大小
SELECT pg_size_pretty(pg_database_size('esports_simulator'));

-- 查看表大小
SELECT
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as size
FROM pg_tables
WHERE schemaname = 'public'
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;
```

### 7.2 性能监控

```sql
-- 查看慢查询
SELECT query, mean_time, calls
FROM pg_stat_statements
ORDER BY mean_time DESC
LIMIT 10;

-- 查看表访问统计
SELECT
    schemaname,
    tablename,
    seq_scan,
    seq_tup_read,
    idx_scan,
    idx_tup_fetch
FROM pg_stat_user_tables
WHERE schemaname = 'public';

-- 查看索引使用情况
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
ORDER BY idx_scan DESC;
```

### 7.3 数据备份

```bash
# 创建完整备份
pg_dump -h localhost -p 5432 -U postgres -d esports_simulator -f backup_$(date +%Y%m%d_%H%M%S).sql

# 创建压缩备份
pg_dump -h localhost -p 5432 -U postgres -d esports_simulator | gzip > backup_$(date +%Y%m%d_%H%M%S).sql.gz

# 只备份数据 (不包含结构)
pg_dump -h localhost -p 5432 -U postgres -d esports_simulator --data-only -f data_backup_$(date +%Y%m%d_%H%M%S).sql

# 恢复备份
psql -h localhost -p 5432 -U postgres -d esports_simulator -f backup_20241010_120000.sql
```

---

## 8. 故障排除

### 8.1 常见问题

#### 问题1: 无法连接数据库
```bash
# 检查服务状态
docker-compose ps postgres

# 查看错误日志
docker-compose logs postgres

# 重启数据库服务
docker-compose restart postgres
```

#### 问题2: 权限错误
```sql
-- 赋予用户权限
GRANT ALL PRIVILEGES ON DATABASE esports_simulator TO postgres;
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO postgres;
GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO postgres;
```

#### 问题3: 表不存在
```sql
-- 检查表是否存在
SELECT table_name FROM information_schema.tables
WHERE table_schema = 'public' AND table_name = 'teams';

-- 重新创建表 (重新执行初始化脚本)
\i /path/to/init-db.sql
```

### 8.2 数据一致性检查

```sql
-- 检查孤立数据
-- 检查没有赛区的战队
SELECT * FROM teams WHERE region_id NOT IN (SELECT id FROM regions);

-- 检查没有战队的比赛
SELECT * FROM matches
WHERE team_a_id NOT IN (SELECT id FROM teams)
   OR team_b_id NOT IN (SELECT id FROM teams);

-- 检查积分记录与战队的一致性
SELECT * FROM score_records
WHERE team_id NOT IN (SELECT id FROM teams);

-- 修复统计数据不一致
UPDATE teams SET
    total_matches = (
        SELECT COUNT(*) FROM matches
        WHERE (team_a_id = teams.id OR team_b_id = teams.id)
        AND status = 'completed'
    ),
    total_wins = (
        SELECT COUNT(*) FROM matches
        WHERE winner_id = teams.id
    ),
    total_losses = (
        SELECT COUNT(*) FROM matches
        WHERE (team_a_id = teams.id OR team_b_id = teams.id)
        AND status = 'completed'
        AND winner_id != teams.id
    );
```

### 8.3 性能优化

```sql
-- 分析慢查询
EXPLAIN ANALYZE SELECT * FROM v_team_rankings WHERE season_year = 2024;

-- 创建缺失的索引
CREATE INDEX IF NOT EXISTS idx_score_records_season_points
ON score_records(season_year, points DESC);

-- 更新表统计信息
ANALYZE teams;
ANALYZE matches;
ANALYZE score_records;
```

---

## 9. 下一步操作建议

### 9.1 完成数据库设置后

1. **验证连接**: 确保应用能正常连接数据库
```bash
cd backend
npm run dev
# 检查控制台是否显示数据库连接成功
```

2. **测试API**: 使用健康检查端点验证
```bash
curl http://localhost:3000/health
```

3. **添加种子数据**: 根据需要添加更多测试数据

### 9.2 开发阶段建议

1. **使用数据库管理工具**:
   - Adminer: http://localhost:8080
   - 用户名: postgres, 密码: postgres, 数据库: esports_simulator

2. **API测试**: 使用 Postman 或类似工具测试API接口

3. **数据监控**: 定期检查数据一致性和性能

### 9.3 生产环境准备

1. **安全配置**: 修改默认密码和权限设置
2. **备份策略**: 建立定期备份机制
3. **监控告警**: 配置数据库性能监控
4. **连接池**: 优化数据库连接池配置

---

## 📞 技术支持

如果在数据库设置过程中遇到问题，可以：

1. **检查日志**: `docker-compose logs postgres`
2. **查看文档**: PostgreSQL官方文档
3. **重新初始化**: 删除数据卷后重新创建

```bash
# 重新初始化数据库 (慎用!)
docker-compose down -v
docker-compose up postgres redis -d
# 然后重新执行初始化步骤
```

**数据库初始化完成后，你就可以开始开发和测试电竞赛事模拟系统的后端功能了！**