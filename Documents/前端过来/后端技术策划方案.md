# ç”µç«èµ›äº‹æ¨¡æ‹Ÿç³»ç»Ÿ - åç«¯æŠ€æœ¯ç­–åˆ’æ–¹æ¡ˆ

## ä¸€ã€é¡¹ç›®æ¦‚è¿°

### 1.1 é¡¹ç›®å®šä½
åŸºäºç”µç«èµ›äº‹æ¨¡æ‹Ÿç³»ç»Ÿç­–åˆ’ä¹¦ï¼Œæ„å»ºä¸€ä¸ªé«˜æ€§èƒ½ã€å¯æ‰©å±•ã€å®‰å…¨å¯é çš„åç«¯æœåŠ¡ç³»ç»Ÿï¼Œæ”¯æŒå¤æ‚çš„èµ›äº‹ç®¡ç†ã€ç§¯åˆ†è®¡ç®—ã€æ•°æ®ç»Ÿè®¡å’Œå®æ—¶æ›´æ–°åŠŸèƒ½ï¼Œä¸ºå‰ç«¯åº”ç”¨æä¾›ç¨³å®šçš„æ•°æ®æœåŠ¡å’Œä¸šåŠ¡é€»è¾‘æ”¯æ’‘ã€‚

### 1.2 æŠ€æœ¯ç›®æ ‡
- **é«˜æ€§èƒ½**ï¼šAPIå“åº”æ—¶é—´ < 200msï¼Œæ”¯æŒå¹¶å‘ç”¨æˆ· > 1000
- **é«˜å¯ç”¨**ï¼šæœåŠ¡å¯ç”¨æ€§ â‰¥ 99.9%ï¼Œæ•…éšœæ¢å¤æ—¶é—´ < 5åˆ†é’Ÿ
- **å¯æ‰©å±•**ï¼šå¾®æœåŠ¡æ¶æ„ï¼Œæ”¯æŒä¸šåŠ¡æ¨¡å—ç‹¬ç«‹æ‰©å±•
- **æ•°æ®ä¸€è‡´æ€§**ï¼šäº‹åŠ¡å¤„ç†ç¡®ä¿æ•°æ®å®Œæ•´æ€§ï¼Œå®æ—¶è®¡ç®—å‡†ç¡®æ€§100%

## äºŒã€æŠ€æœ¯æ¶æ„æ–¹æ¡ˆ

### 2.1 æ•´ä½“æ¶æ„
```
åç«¯æœåŠ¡æ¶æ„
â”œâ”€â”€ åº”ç”¨å±‚ (Application Layer)
â”‚   â”œâ”€â”€ APIç½‘å…³ (API Gateway)
â”‚   â”œâ”€â”€ è®¤è¯æœåŠ¡ (Auth Service)
â”‚   â””â”€â”€ è´Ÿè½½å‡è¡¡ (Load Balancer)
â”œâ”€â”€ æœåŠ¡å±‚ (Service Layer)
â”‚   â”œâ”€â”€ æˆ˜é˜Ÿç®¡ç†æœåŠ¡ (Team Service)
â”‚   â”œâ”€â”€ èµ›äº‹ç®¡ç†æœåŠ¡ (Competition Service)
â”‚   â”œâ”€â”€ èµ›ç¨‹ç®¡ç†æœåŠ¡ (Schedule Service)
â”‚   â”œâ”€â”€ ç§¯åˆ†è®¡ç®—æœåŠ¡ (Score Service)
â”‚   â”œâ”€â”€ ç»Ÿè®¡åˆ†ææœåŠ¡ (Statistics Service)
â”‚   â””â”€â”€ é€šçŸ¥æœåŠ¡ (Notification Service)
â”œâ”€â”€ ä¸šåŠ¡é€»è¾‘å±‚ (Business Logic Layer)
â”‚   â”œâ”€â”€ èµ›åˆ¶å¼•æ“ (Competition Engine)
â”‚   â”œâ”€â”€ ç§¯åˆ†å¼•æ“ (Scoring Engine)
â”‚   â”œâ”€â”€ æ¨¡æ‹Ÿå¼•æ“ (Simulation Engine)
â”‚   â”œâ”€â”€ æŠ½ç­¾å¼•æ“ (Draw Engine)
â”‚   â””â”€â”€ æ•°æ®éªŒè¯ (Validation)
â”œâ”€â”€ æ•°æ®è®¿é—®å±‚ (Data Access Layer)
â”‚   â”œâ”€â”€ æ•°æ®åº“å±‚ (Database)
â”‚   â”œâ”€â”€ ç¼“å­˜å±‚ (Cache)
â”‚   â””â”€â”€ æ–‡ä»¶å­˜å‚¨ (File Storage)
â””â”€â”€ åŸºç¡€è®¾æ–½å±‚ (Infrastructure Layer)
    â”œâ”€â”€ ç›‘æ§å‘Šè­¦ (Monitoring)
    â”œâ”€â”€ æ—¥å¿—ç®¡ç† (Logging)
    â””â”€â”€ é…ç½®ç®¡ç† (Configuration)
```

### 2.2 æ ¸å¿ƒæŠ€æœ¯æ ˆé€‰å‹

#### 2.2.1 ä¸»æœåŠ¡æ¡†æ¶
- **åç«¯æ¡†æ¶**: Node.js + Express.js 4.18+
  - é€‰æ‹©ç†ç”±ï¼šå¼€å‘æ•ˆç‡é«˜ã€ç”Ÿæ€ä¸°å¯Œã€JavaScriptå…¨æ ˆä¸€è‡´æ€§
  - æ›¿ä»£æ–¹æ¡ˆï¼šNest.jsï¼ˆä¼ä¸šçº§é¡¹ç›®ï¼‰ã€Fastifyï¼ˆé«˜æ€§èƒ½è¦æ±‚ï¼‰
- **å¼€å‘è¯­è¨€**: TypeScript 5.0+
  - é€‰æ‹©ç†ç”±ï¼šç±»å‹å®‰å…¨ã€ä»£ç æç¤ºã€é‡æ„å‹å¥½ã€å›¢é˜Ÿåä½œ

#### 2.2.2 æ•°æ®åº“ç³»ç»Ÿ
- **ä¸»æ•°æ®åº“**: PostgreSQL 15+
  - é€‰æ‹©ç†ç”±ï¼šäº‹åŠ¡æ”¯æŒå®Œå–„ã€JSONå­—æ®µæ”¯æŒã€å¤æ‚æŸ¥è¯¢æ€§èƒ½ä¼˜ç§€
  - é…ç½®ï¼šè¯»å†™åˆ†ç¦»ã€è¿æ¥æ± ç®¡ç†ã€ç´¢å¼•ä¼˜åŒ–
- **ç¼“å­˜æ•°æ®åº“**: Redis 7.0+
  - é€‰æ‹©ç†ç”±ï¼šé«˜æ€§èƒ½ã€æ•°æ®ç»“æ„ä¸°å¯Œã€åˆ†å¸ƒå¼æ”¯æŒ
  - åº”ç”¨åœºæ™¯ï¼šä¼šè¯å­˜å‚¨ã€è®¡ç®—ç»“æœç¼“å­˜ã€å®æ—¶æ•°æ®ç¼“å­˜

#### 2.2.3 APIè®¾è®¡
- **APIé£æ ¼**: RESTful API + GraphQL
  - RESTfulï¼šå¸¸è§„CRUDæ“ä½œ
  - GraphQLï¼šå¤æ‚æ•°æ®æŸ¥è¯¢å’Œå®æ—¶è®¢é˜…
- **APIæ–‡æ¡£**: OpenAPI 3.0 + Swagger UI
  - è‡ªåŠ¨ç”ŸæˆAPIæ–‡æ¡£
  - æ¥å£æµ‹è¯•æ”¯æŒ

#### 2.2.4 æ¶ˆæ¯é˜Ÿåˆ—
- **æ¶ˆæ¯ç³»ç»Ÿ**: Redis Pub/Sub + Bull Queue
  - é€‰æ‹©ç†ç”±ï¼šè½»é‡çº§ã€å»¶è¿Ÿä½ã€æ˜“äºéƒ¨ç½²
  - åº”ç”¨åœºæ™¯ï¼šèµ›äº‹ç»“æœé€šçŸ¥ã€ç§¯åˆ†è®¡ç®—ä»»åŠ¡ã€æ•°æ®åŒæ­¥

### 2.3 æ•°æ®æ¨¡å‹è®¾è®¡

#### 2.3.1 æ ¸å¿ƒå®ä½“å…³ç³»
```sql
-- æˆ˜é˜Ÿè¡¨
CREATE TABLE teams (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) NOT NULL UNIQUE,
    region_id UUID NOT NULL REFERENCES regions(id),
    power_rating INTEGER CHECK (power_rating >= 0 AND power_rating <= 100),
    founded_date DATE,
    total_matches INTEGER DEFAULT 0,
    total_wins INTEGER DEFAULT 0,
    total_losses INTEGER DEFAULT 0,
    net_round_difference INTEGER DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- èµ›åŒºè¡¨
CREATE TABLE regions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(50) NOT NULL UNIQUE,
    display_order INTEGER,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- èµ›å­£è¡¨
CREATE TABLE seasons (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) NOT NULL,
    year INTEGER NOT NULL,
    status VARCHAR(20) DEFAULT 'planning', -- planning, active, completed
    current_phase VARCHAR(50), -- spring_regular, spring_playoffs, msi, etc.
    start_date DATE,
    end_date DATE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- èµ›äº‹è¡¨
CREATE TABLE competitions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    season_id UUID NOT NULL REFERENCES seasons(id),
    type VARCHAR(30) NOT NULL, -- spring, summer, msi, worlds, intercontinental
    name VARCHAR(100) NOT NULL,
    status VARCHAR(20) DEFAULT 'upcoming', -- upcoming, active, completed
    format JSONB NOT NULL, -- èµ›åˆ¶é…ç½®
    scoring_rules JSONB NOT NULL, -- ç§¯åˆ†è§„åˆ™
    start_date DATE,
    end_date DATE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- æ¯”èµ›è¡¨
CREATE TABLE matches (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    competition_id UUID NOT NULL REFERENCES competitions(id),
    team_a_id UUID NOT NULL REFERENCES teams(id),
    team_b_id UUID NOT NULL REFERENCES teams(id),
    round_number INTEGER,
    phase VARCHAR(50), -- regular, playoffs, quarterfinals, etc.
    format VARCHAR(10), -- BO3, BO5
    score_a INTEGER DEFAULT 0,
    score_b INTEGER DEFAULT 0,
    winner_id UUID REFERENCES teams(id),
    status VARCHAR(20) DEFAULT 'scheduled', -- scheduled, in_progress, completed
    scheduled_at TIMESTAMP WITH TIME ZONE,
    completed_at TIMESTAMP WITH TIME ZONE,
    match_data JSONB, -- é¢å¤–æ¯”èµ›æ•°æ®
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- ç§¯åˆ†è®°å½•è¡¨
CREATE TABLE score_records (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    team_id UUID NOT NULL REFERENCES teams(id),
    competition_id UUID NOT NULL REFERENCES competitions(id),
    match_id UUID REFERENCES matches(id),
    points INTEGER NOT NULL,
    point_type VARCHAR(30), -- match_win, tournament_placement, etc.
    season_year INTEGER NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- æŠ½ç­¾è®°å½•è¡¨
CREATE TABLE draw_records (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    competition_id UUID NOT NULL REFERENCES competitions(id),
    phase VARCHAR(50) NOT NULL,
    draw_data JSONB NOT NULL, -- æŠ½ç­¾ç»“æœæ•°æ®
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

#### 2.3.2 ç´¢å¼•ä¼˜åŒ–ç­–ç•¥
```sql
-- æ€§èƒ½å…³é”®ç´¢å¼•
CREATE INDEX idx_teams_region ON teams(region_id);
CREATE INDEX idx_teams_power_rating ON teams(power_rating);
CREATE INDEX idx_matches_competition ON matches(competition_id);
CREATE INDEX idx_matches_teams ON matches(team_a_id, team_b_id);
CREATE INDEX idx_matches_date ON matches(scheduled_at);
CREATE INDEX idx_score_records_team_season ON score_records(team_id, season_year);
CREATE INDEX idx_score_records_competition ON score_records(competition_id);

-- å¤åˆç´¢å¼•
CREATE INDEX idx_matches_competition_phase ON matches(competition_id, phase);
CREATE INDEX idx_teams_region_rating ON teams(region_id, power_rating);
```

## ä¸‰ã€æ ¸å¿ƒåŠŸèƒ½æ¨¡å—æŠ€æœ¯å®ç°

### 3.1 æˆ˜é˜Ÿç®¡ç†æœåŠ¡

#### 3.1.1 æœåŠ¡æ¶æ„
```typescript
// æˆ˜é˜Ÿç®¡ç†æœåŠ¡
class TeamService {
    constructor(
        private teamRepository: TeamRepository,
        private cacheService: CacheService,
        private eventBus: EventBus
    ) {}

    // åˆ›å»ºæˆ˜é˜Ÿ
    async createTeam(teamData: CreateTeamDto): Promise<Team> {
        const team = await this.teamRepository.create(teamData);
        await this.cacheService.invalidate(`region:${team.regionId}:teams`);
        this.eventBus.emit('team.created', team);
        return team;
    }

    // æ›´æ–°æˆ˜é˜Ÿä¿¡æ¯
    async updateTeam(id: string, updateData: UpdateTeamDto): Promise<Team> {
        const team = await this.teamRepository.update(id, updateData);
        await this.cacheService.invalidate([
            `team:${id}`,
            `region:${team.regionId}:teams`
        ]);
        this.eventBus.emit('team.updated', team);
        return team;
    }

    // è·å–æˆ˜é˜Ÿç»Ÿè®¡
    async getTeamStatistics(teamId: string): Promise<TeamStatistics> {
        const cacheKey = `team:${teamId}:stats`;
        let stats = await this.cacheService.get(cacheKey);

        if (!stats) {
            stats = await this.calculateTeamStatistics(teamId);
            await this.cacheService.set(cacheKey, stats, 300); // 5åˆ†é’Ÿç¼“å­˜
        }

        return stats;
    }

    // è®¡ç®—æˆ˜é˜Ÿç»Ÿè®¡æ•°æ®
    private async calculateTeamStatistics(teamId: string): Promise<TeamStatistics> {
        const [matches, scores] = await Promise.all([
            this.teamRepository.getTeamMatches(teamId),
            this.teamRepository.getTeamScores(teamId)
        ]);

        return {
            totalMatches: matches.length,
            wins: matches.filter(m => m.winnerId === teamId).length,
            losses: matches.filter(m => m.winnerId !== teamId && m.winnerId !== null).length,
            winRate: this.calculateWinRate(matches, teamId),
            totalPoints: scores.reduce((sum, score) => sum + score.points, 0),
            averagePointsPerCompetition: this.calculateAveragePoints(scores)
        };
    }
}
```

#### 3.1.2 æ•°æ®è®¿é—®å±‚
```typescript
// æˆ˜é˜Ÿæ•°æ®è®¿é—®å±‚
class TeamRepository {
    constructor(private db: Database) {}

    async create(teamData: CreateTeamDto): Promise<Team> {
        const query = `
            INSERT INTO teams (name, region_id, power_rating, founded_date)
            VALUES ($1, $2, $3, $4)
            RETURNING *
        `;
        const result = await this.db.query(query, [
            teamData.name,
            teamData.regionId,
            teamData.powerRating,
            teamData.foundedDate
        ]);
        return result.rows[0];
    }

    async getTeamsByRegion(regionId: string): Promise<Team[]> {
        const query = `
            SELECT t.*, r.name as region_name
            FROM teams t
            JOIN regions r ON t.region_id = r.id
            WHERE t.region_id = $1
            ORDER BY t.power_rating DESC
        `;
        const result = await this.db.query(query, [regionId]);
        return result.rows;
    }

    async getTeamMatches(teamId: string, limit?: number): Promise<Match[]> {
        const query = `
            SELECT m.*, ta.name as team_a_name, tb.name as team_b_name
            FROM matches m
            JOIN teams ta ON m.team_a_id = ta.id
            JOIN teams tb ON m.team_b_id = tb.id
            WHERE m.team_a_id = $1 OR m.team_b_id = $1
            ORDER BY m.completed_at DESC
            ${limit ? 'LIMIT $2' : ''}
        `;
        const params = limit ? [teamId, limit] : [teamId];
        const result = await this.db.query(query, params);
        return result.rows;
    }
}
```

### 3.2 èµ›ç¨‹ç®¡ç†æœåŠ¡

#### 3.2.1 æœåŠ¡æ¶æ„
```typescript
// èµ›ç¨‹ç®¡ç†æœåŠ¡
class ScheduleService {
    constructor(
        private scheduleRepository: ScheduleRepository,
        private matchService: MatchService,
        private simulationEngine: SimulationEngine,
        private cacheService: CacheService,
        private eventBus: EventBus
    ) {}

    // è·å–å½“å‰èµ›ç¨‹çŠ¶æ€
    async getCurrentSchedule(competitionId: string): Promise<ScheduleStatus> {
        const cacheKey = `schedule:${competitionId}:current`;
        let schedule = await this.cacheService.get(cacheKey);

        if (!schedule) {
            schedule = await this.calculateCurrentSchedule(competitionId);
            await this.cacheService.set(cacheKey, schedule, 600); // 10åˆ†é’Ÿç¼“å­˜
        }

        return schedule;
    }

    // æ¨è¿›åˆ°ä¸‹ä¸€è½®
    async proceedToNextRound(competitionId: string): Promise<RoundResult> {
        const competition = await this.getCompetition(competitionId);
        if (!competition) {
            throw new Error('Competition not found');
        }

        const currentRound = await this.getCurrentRound(competitionId);
        const nextRoundMatches = await this.getNextRoundMatches(competitionId, currentRound + 1);

        if (nextRoundMatches.length === 0) {
            throw new Error('No more rounds available');
        }

        // æ¨¡æ‹Ÿå½“å‰è½®æ¬¡çš„æ‰€æœ‰æ¯”èµ›
        const simulationResults = await this.simulateRoundMatches(nextRoundMatches);

        // æ›´æ–°æ¯”èµ›ç»“æœ
        await this.updateMatchResults(simulationResults);

        // æ›´æ–°ç§¯åˆ†æ¦œ
        const updatedScoreboard = await this.updateScoreboard(competitionId, simulationResults);

        // æ›´æ–°è½®æ¬¡çŠ¶æ€
        await this.updateRoundStatus(competitionId, currentRound + 1, 'completed');

        // æ¸…é™¤ç¼“å­˜
        await this.invalidateScheduleCache(competitionId);

        // å‘é€äº‹ä»¶é€šçŸ¥
        this.eventBus.emit('round.completed', {
            competitionId,
            round: currentRound + 1,
            results: simulationResults,
            scoreboard: updatedScoreboard
        });

        return {
            round: currentRound + 1,
            matches: simulationResults,
            scoreboard: updatedScoreboard,
            nextRound: await this.getNextAvailableRound(competitionId)
        };
    }

    // æ¨¡æ‹Ÿè½®æ¬¡æ¯”èµ›
    private async simulateRoundMatches(matches: Match[]): Promise<MatchResult[]> {
        const results: MatchResult[] = [];

        for (const match of matches) {
            const [teamA, teamB] = await Promise.all([
                this.getTeamById(match.teamAId),
                this.getTeamById(match.teamBId)
            ]);

            const result = await this.simulationEngine.simulateMatch(teamA, teamB);
            results.push({
                matchId: match.id,
                teamAId: match.teamAId,
                teamBId: match.teamBId,
                scoreA: result.scoreA,
                scoreB: result.scoreB,
                winnerId: result.winnerId,
                simulatedAt: new Date()
            });
        }

        return results;
    }

    // è®¡ç®—å½“å‰èµ›ç¨‹çŠ¶æ€
    private async calculateCurrentSchedule(competitionId: string): Promise<ScheduleStatus> {
        const [competition, allMatches, currentRound] = await Promise.all([
            this.getCompetition(competitionId),
            this.getAllMatches(competitionId),
            this.getCurrentRound(competitionId)
        ]);

        const totalRounds = await this.getTotalRounds(competitionId);
        const completedMatches = allMatches.filter(m => m.status === 'completed');
        const upcomingMatches = allMatches.filter(m => m.status === 'scheduled' && m.roundNumber === currentRound + 1);

        return {
            competitionId,
            currentRound,
            totalRounds,
            completedMatches: completedMatches.length,
            totalMatches: allMatches.length,
            upcomingMatches,
            isCompleted: currentRound >= totalRounds,
            scoreboard: await this.getCurrentScoreboard(competitionId)
        };
    }
}
```

#### 3.2.2 æˆ˜åŠ›æ¨¡æ‹Ÿå¼•æ“
```typescript
// æˆ˜åŠ›æ¨¡æ‹Ÿè®¡ç®—å¼•æ“
class SimulationEngine {
    private readonly BASE_RANDOMNESS = 0.2; // åŸºç¡€éšæœºæ€§å› å­
    private readonly POWER_SCALING = 0.015; // æˆ˜åŠ›å½±å“ç³»æ•°

    // æ¨¡æ‹Ÿå•åœºæ¯”èµ›
    async simulateMatch(teamA: Team, teamB: Team): Promise<MatchSimulationResult> {
        // è·å–æˆ˜é˜Ÿå½“å‰çŠ¶æ€
        const teamAStats = await this.getTeamCurrentStats(teamA.id);
        const teamBStats = await this.getTeamCurrentStats(teamB.id);

        // è®¡ç®—è°ƒæ•´åçš„æˆ˜åŠ›å€¼
        const adjustedPowerA = this.calculateAdjustedPower(teamA, teamAStats);
        const adjustedPowerB = this.calculateAdjustedPower(teamB, teamBStats);

        // è®¡ç®—èƒœç‡
        const winProbabilityA = this.calculateWinProbability(adjustedPowerA, adjustedPowerB);

        // è¿›è¡Œæ¯”èµ›æ¨¡æ‹Ÿ
        const matchResult = this.simulateMatchExecution(winProbabilityA);

        // è®°å½•æ¨¡æ‹Ÿæ—¥å¿—
        await this.logSimulation(teamA, teamB, matchResult, {
            adjustedPowerA,
            adjustedPowerB,
            winProbabilityA
        });

        return {
            scoreA: matchResult.scoreA,
            scoreB: matchResult.scoreB,
            winnerId: matchResult.winnerId,
            simulationData: {
                winProbability: winProbabilityA,
                powerDifference: adjustedPowerA - adjustedPowerB,
                randomFactor: matchResult.randomFactor
            }
        };
    }

    // è®¡ç®—è°ƒæ•´åçš„æˆ˜åŠ›å€¼
    private calculateAdjustedPower(team: Team, stats: TeamCurrentStats): number {
        let adjustedPower = team.powerRating;

        // è€ƒè™‘æœ€è¿‘è¡¨ç°
        if (stats.recentMatches.length > 0) {
            const recentWinRate = stats.recentWins / stats.recentMatches.length;
            const formFactor = (recentWinRate - 0.5) * 10; // -5 åˆ° +5 çš„è°ƒæ•´
            adjustedPower += formFactor;
        }

        // è€ƒè™‘è¿èƒœ/è¿è´¥
        if (stats.currentStreak > 0) {
            adjustedPower += Math.min(stats.currentStreak * 2, 10); // è¿èƒœåŠ æˆï¼Œæœ€å¤š+10
        } else if (stats.currentStreak < 0) {
            adjustedPower -= Math.min(Math.abs(stats.currentStreak) * 1.5, 8); // è¿è´¥å‡æˆï¼Œæœ€å¤š-8
        }

        // é™åˆ¶åœ¨åˆç†èŒƒå›´å†…
        return Math.max(0, Math.min(100, adjustedPower));
    }

    // è®¡ç®—èƒœç‡
    private calculateWinProbability(powerA: number, powerB: number): number {
        const powerDiff = powerA - powerB;

        // ä½¿ç”¨ä¿®æ­£çš„Sigmoidå‡½æ•°
        const scaledDiff = powerDiff * this.POWER_SCALING;
        const baseProbability = 1 / (1 + Math.exp(-scaledDiff));

        // æ·»åŠ åŸºç¡€éšæœºæ€§ï¼Œç¡®ä¿æ²¡æœ‰100%çš„èƒœç‡
        const minProbability = 0.1;
        const maxProbability = 0.9;

        return Math.max(minProbability, Math.min(maxProbability, baseProbability));
    }

    // æ‰§è¡Œæ¯”èµ›æ¨¡æ‹Ÿ
    private simulateMatchExecution(winProbabilityA: number): MatchExecutionResult {
        const randomFactor = Math.random();
        const isTeamAWin = randomFactor < winProbabilityA;

        // æ ¹æ®èƒœç‡å·®è·å†³å®šæ¯”åˆ†
        const scoreDiff = Math.abs(winProbabilityA - 0.5);
        let scoreA: number, scoreB: number;

        if (scoreDiff > 0.25) {
            // å®åŠ›å·®è·è¾ƒå¤§ï¼Œæ›´å®¹æ˜“å‡ºç°2-0
            if (Math.random() > 0.3) {
                [scoreA, scoreB] = isTeamAWin ? [2, 0] : [0, 2];
            } else {
                [scoreA, scoreB] = isTeamAWin ? [2, 1] : [1, 2];
            }
        } else {
            // å®åŠ›æ¥è¿‘ï¼Œæ›´å®¹æ˜“å‡ºç°2-1
            if (Math.random() > 0.4) {
                [scoreA, scoreB] = isTeamAWin ? [2, 1] : [1, 2];
            } else {
                [scoreA, scoreB] = isTeamAWin ? [2, 0] : [0, 2];
            }
        }

        return {
            scoreA,
            scoreB,
            winnerId: scoreA > scoreB ? 'teamA' : 'teamB',
            randomFactor
        };
    }

    // æ‰¹é‡æ¨¡æ‹Ÿè½®æ¬¡
    async simulateRound(matches: Match[]): Promise<MatchSimulationResult[]> {
        const results: MatchSimulationResult[] = [];

        // å¹¶è¡Œæ¨¡æ‹Ÿæ‰€æœ‰æ¯”èµ›
        const simulationPromises = matches.map(async (match) => {
            const [teamA, teamB] = await Promise.all([
                this.getTeamById(match.teamAId),
                this.getTeamById(match.teamBId)
            ]);

            return this.simulateMatch(teamA, teamB);
        });

        const simulationResults = await Promise.all(simulationPromises);

        // ç»„è£…ç»“æœ
        for (let i = 0; i < matches.length; i++) {
            results.push({
                matchId: matches[i].id,
                ...simulationResults[i]
            });
        }

        return results;
    }

    // è®°å½•æ¨¡æ‹Ÿæ—¥å¿—
    private async logSimulation(
        teamA: Team,
        teamB: Team,
        result: MatchExecutionResult,
        metadata: any
    ): Promise<void> {
        const logEntry = {
            timestamp: new Date(),
            teamA: { id: teamA.id, name: teamA.name, power: metadata.adjustedPowerA },
            teamB: { id: teamB.id, name: teamB.name, power: metadata.adjustedPowerB },
            result: {
                score: `${result.scoreA}-${result.scoreB}`,
                winner: result.winnerId
            },
            simulation: {
                winProbability: metadata.winProbabilityA,
                randomFactor: result.randomFactor
            }
        };

        // è®°å½•åˆ°æ—¥å¿—ç³»ç»Ÿ
        await this.logger.info('Match simulation completed', logEntry);
    }
}
```

### 3.4 è‡ªåŠ¨èµ›äº‹ç”ŸæˆæœåŠ¡ ğŸ†•

#### 3.4.1 æ ¸å¿ƒä¸šåŠ¡é€»è¾‘é‡æ„
**é‡å¤§æ¶æ„è°ƒæ•´**ï¼šåŸºäºç”²æ–¹éœ€æ±‚ï¼Œèµ›äº‹åˆ›å»ºä»æ‰‹åŠ¨æ“ä½œè½¬ä¸ºå®Œå…¨è‡ªåŠ¨åŒ–æœºåˆ¶ã€‚

```typescript
// è‡ªåŠ¨èµ›äº‹ç”ŸæˆæœåŠ¡
class AutoTournamentService {
    constructor(
        private competitionService: CompetitionService,
        private teamService: TeamService,
        private ruleEngine: RuleEngine,
        private eventBus: EventBus,
        private logger: Logger
    ) {}

    // æ ¸å¿ƒç›‘å¬æœºåˆ¶ï¼šç›‘å¬èµ›äº‹çŠ¶æ€å˜åŒ–
    async onCompetitionStatusChanged(competition: Competition): Promise<void> {
        if (competition.status === 'completed') {
            await this.checkAndTriggerAutoGeneration(competition)
        }
    }

    // æ£€æŸ¥å¹¶è§¦å‘è‡ªåŠ¨ç”Ÿæˆ
    private async checkAndTriggerAutoGeneration(completedCompetition: Competition): Promise<void> {
        const applicableRules = await this.ruleEngine.findApplicableRules(completedCompetition)

        this.logger.info(`Found ${applicableRules.length} applicable rules for competition ${completedCompetition.id}`)

        for (const rule of applicableRules) {
            try {
                const result = await this.executeAutoGeneration(rule, completedCompetition)
                this.eventBus.emit('auto-tournament.generated', {
                    rule,
                    sourceCompetition: completedCompetition,
                    generatedCompetition: result.competition,
                    selectedTeams: result.teams
                })
            } catch (error) {
                this.logger.error(`Auto generation failed for rule ${rule.id}`, error)
                this.eventBus.emit('auto-tournament.failed', { rule, error })
            }
        }
    }

    // æ‰§è¡Œè‡ªåŠ¨ç”Ÿæˆé€»è¾‘
    private async executeAutoGeneration(
        rule: AutoGenerationRule,
        sourceCompetition: Competition
    ): Promise<AutoGenerationResult> {
        // 1. æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ç›¸åŒç±»å‹çš„èµ›äº‹
        const existingCompetition = await this.competitionService.findExisting(
            rule.targetCompetitionType,
            sourceCompetition.seasonId
        )

        if (existingCompetition) {
            throw new Error(`Competition ${rule.targetCompetitionType} already exists for season`)
        }

        // 2. æ ¹æ®è§„åˆ™é€‰æ‹©å‚èµ›é˜Ÿä¼
        const selectedTeams = await this.selectTeamsByRule(rule, sourceCompetition)

        if (selectedTeams.length < rule.minimumTeams) {
            throw new Error(`Insufficient teams: ${selectedTeams.length} < ${rule.minimumTeams}`)
        }

        // 3. åˆ›å»ºæ–°èµ›äº‹
        const newCompetition = await this.competitionService.createAutoGenerated({
            name: rule.competitionName,
            type: rule.targetCompetitionType,
            format: rule.format,
            seasonId: sourceCompetition.seasonId,
            teams: selectedTeams,
            autoGenerated: true,
            sourceCompetitionId: sourceCompetition.id,
            generationRuleId: rule.id
        })

        // 4. ç”Ÿæˆåˆå§‹èµ›ç¨‹ï¼ˆå¦‚éœ€è¦ï¼‰
        if (rule.autoGenerateSchedule) {
            await this.competitionService.generateSchedule(newCompetition.id)
        }

        // 5. è®°å½•ç”Ÿæˆå†å²
        await this.logAutoGeneration(rule, sourceCompetition, newCompetition, selectedTeams)

        return {
            competition: newCompetition,
            teams: selectedTeams,
            rule
        }
    }

    // æ™ºèƒ½é˜Ÿä¼é€‰æ‹©ç®—æ³•
    private async selectTeamsByRule(
        rule: AutoGenerationRule,
        sourceCompetition: Competition
    ): Promise<Team[]> {
        switch (rule.teamSelectionStrategy) {
            case 'regional_champions':
                return this.selectRegionalChampions(rule.targetRegions)

            case 'playoff_winners':
                return this.selectPlayoffWinners(sourceCompetition, rule.teamCount)

            case 'top_ranked_teams':
                return this.selectTopRankedTeams(rule.teamCount, rule.targetRegions)

            case 'intercontinental_qualified':
                return this.selectIntercontinentalQualified(rule.teamCount)

            default:
                throw new Error(`Unknown team selection strategy: ${rule.teamSelectionStrategy}`)
        }
    }

    // è·å–èµ›åŒºå† å†›
    private async selectRegionalChampions(targetRegions: string[]): Promise<Team[]> {
        const champions: Team[] = []

        for (const regionId of targetRegions) {
            // æŸ¥æ‰¾è¯¥èµ›åŒºæœ€è¿‘å®Œæˆçš„å­£åèµ›
            const recentPlayoffs = await this.competitionService.findRecentPlayoffs(regionId)

            if (recentPlayoffs) {
                const champion = await this.getPlayoffChampion(recentPlayoffs.id)
                if (champion) {
                    champions.push(champion)
                }
            } else {
                // å¦‚æœæ²¡æœ‰å­£åèµ›ï¼Œé€‰æ‹©ç§¯åˆ†æœ€é«˜çš„é˜Ÿä¼
                const topTeam = await this.teamService.getTopTeamByRegion(regionId)
                if (topTeam) {
                    champions.push(topTeam)
                }
            }
        }

        return champions
    }

    // è·å–å­£åèµ›è·èƒœè€…
    private async selectPlayoffWinners(
        playoffCompetition: Competition,
        count: number
    ): Promise<Team[]> {
        // æ ¹æ®å­£åèµ›ç»“æœæ’åºï¼Œé€‰æ‹©å‰Nå
        const rankedTeams = await this.competitionService.getRankedTeams(playoffCompetition.id)
        return rankedTeams.slice(0, count)
    }

    // æ´²é™…èµ›èµ„æ ¼é˜Ÿä¼é€‰æ‹©ï¼ˆè·¨å¹´åº¦ç§¯åˆ†ï¼‰
    private async selectIntercontinentalQualified(count: number): Promise<Team[]> {
        const currentYear = new Date().getFullYear()
        const previousYear = currentYear - 1

        // è®¡ç®—è·¨å¹´åº¦ç§¯åˆ†æ’å
        const crossYearRanking = await this.teamService.getCrossYearRanking(
            previousYear,
            currentYear
        )

        return crossYearRanking.slice(0, count)
    }

    // è®°å½•è‡ªåŠ¨ç”Ÿæˆå†å²
    private async logAutoGeneration(
        rule: AutoGenerationRule,
        source: Competition,
        generated: Competition,
        teams: Team[]
    ): Promise<void> {
        const logEntry = {
            ruleId: rule.id,
            ruleName: rule.name,
            sourceCompetitionId: source.id,
            sourceCompetitionName: source.name,
            generatedCompetitionId: generated.id,
            generatedCompetitionName: generated.name,
            selectedTeamIds: teams.map(t => t.id),
            selectedTeamNames: teams.map(t => t.name),
            executedAt: new Date(),
            seasonId: source.seasonId
        }

        await this.autoGenerationLogRepository.create(logEntry)

        this.logger.info('Auto generation completed', logEntry)
    }
}
```

#### 3.4.2 è§„åˆ™å¼•æ“è®¾è®¡
```typescript
// è§„åˆ™å¼•æ“
class RuleEngine {
    private rules: AutoGenerationRule[] = [
        {
            id: 'spring-regular-to-playoffs',
            name: 'æ˜¥å­£å¸¸è§„èµ›â†’æ˜¥å­£å­£åèµ›',
            trigger: {
                competitionType: 'spring',
                format: 'regular_season',
                status: 'completed'
            },
            action: {
                targetCompetitionType: 'spring',
                format: 'playoffs',
                competitionName: 'æ˜¥å­£å­£åèµ›',
                teamSelectionStrategy: 'top_ranked_teams',
                teamCount: 8,
                autoGenerateSchedule: true
            },
            enabled: true
        },
        {
            id: 'summer-playoffs-to-worlds',
            name: 'å¤å­£å­£åèµ›â†’å…¨çƒæ€»å†³èµ›',
            trigger: {
                competitionType: 'summer',
                format: 'playoffs',
                status: 'completed'
            },
            action: {
                targetCompetitionType: 'worlds',
                format: 'worlds_format',
                competitionName: 'å…¨çƒæ€»å†³èµ›',
                teamSelectionStrategy: 'regional_champions',
                targetRegions: ['LPL', 'LCK', 'LEC', 'LCS'],
                teamCount: 16,
                autoGenerateSchedule: true
            },
            enabled: true
        },
        {
            id: 'worlds-to-intercontinental',
            name: 'å…¨çƒæ€»å†³èµ›â†’æ´²é™…è¶…çº§æ¯',
            trigger: {
                competitionType: 'worlds',
                status: 'completed'
            },
            action: {
                targetCompetitionType: 'intercontinental',
                format: 'four_stage',
                competitionName: 'æ´²é™…è¶…çº§æ¯',
                teamSelectionStrategy: 'intercontinental_qualified',
                teamCount: 16,
                autoGenerateSchedule: false, // éœ€è¦åˆ†é˜¶æ®µç”Ÿæˆ
                requiresCrossYearRanking: true
            },
            enabled: true
        }
    ]

    // æŸ¥æ‰¾é€‚ç”¨è§„åˆ™
    async findApplicableRules(competition: Competition): Promise<AutoGenerationRule[]> {
        return this.rules.filter(rule => {
            if (!rule.enabled) return false

            const trigger = rule.trigger

            // æ£€æŸ¥èµ›äº‹ç±»å‹
            if (trigger.competitionType && trigger.competitionType !== competition.type) {
                return false
            }

            // æ£€æŸ¥èµ›åˆ¶æ ¼å¼
            if (trigger.format && trigger.format !== competition.format) {
                return false
            }

            // æ£€æŸ¥çŠ¶æ€
            if (trigger.status && trigger.status !== competition.status) {
                return false
            }

            return true
        })
    }

    // åŠ¨æ€æ›´æ–°è§„åˆ™
    async updateRule(ruleId: string, updates: Partial<AutoGenerationRule>): Promise<void> {
        const ruleIndex = this.rules.findIndex(rule => rule.id === ruleId)
        if (ruleIndex !== -1) {
            this.rules[ruleIndex] = { ...this.rules[ruleIndex], ...updates }
            await this.persistRules()
        }
    }

    // æ·»åŠ è‡ªå®šä¹‰è§„åˆ™
    async addCustomRule(rule: AutoGenerationRule): Promise<void> {
        this.rules.push(rule)
        await this.persistRules()
    }
}
```

#### 3.4.3 æ•°æ®èšåˆæœåŠ¡å¢å¼º
```typescript
// æ¨ªå¹…æ•°æ®èšåˆæœåŠ¡
class BannerDataService {
    // è·å–èµ›äº‹æ¨ªå¹…æ•°æ®
    async getCompetitionBannerData(type?: CompetitionType): Promise<CompetitionBannerData[]> {
        const competitions = type
            ? await this.competitionRepository.findByType(type)
            : await this.competitionRepository.findAll()

        const bannerData = await Promise.all(
            competitions.map(async (competition) => {
                const [champion, regionCount, participantCount] = await Promise.all([
                    this.getCompetitionChampion(competition.id),
                    this.getParticipatingRegionCount(competition.id),
                    this.getParticipantCount(competition.id)
                ])

                return {
                    id: competition.id,
                    name: competition.name,
                    type: competition.type,
                    status: competition.status,
                    format: competition.format,
                    champion,
                    regionCount,
                    participantCount,
                    createdAt: competition.createdAt,
                    scheduledAt: competition.scheduledAt,
                    completedAt: competition.completedAt,
                    isAutoGenerated: competition.autoGenerated || false
                }
            })
        )

        return bannerData.sort((a, b) =>
            new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
        )
    }

    // è·å–å† å†›å¢™æ•°æ®
    async getChampionsWallData(competitionType?: CompetitionType): Promise<ChampionWallData[]> {
        const completedCompetitions = await this.competitionRepository.findCompleted(competitionType)

        const championsData = await Promise.all(
            completedCompetitions.map(async (competition) => {
                const champion = await this.getCompetitionChampion(competition.id)
                const region = champion ? await this.regionRepository.findById(champion.regionId) : null

                return {
                    competitionId: competition.id,
                    competitionName: competition.name,
                    competitionType: competition.type,
                    championTeam: champion,
                    championRegion: region,
                    completedAt: competition.completedAt,
                    season: await this.getCompetitionSeason(competition.id)
                }
            })
        )

        return championsData
            .filter(data => data.championTeam !== null)
            .sort((a, b) =>
                new Date(b.completedAt).getTime() - new Date(a.completedAt).getTime()
            )
    }

    // è·å–å¹´åº¦æ±‡æ€»æ•°æ®
    async getAnnualSummaryData(year: number): Promise<AnnualSummaryData> {
        const [competitions, statistics, timeline] = await Promise.all([
            this.competitionRepository.findByYear(year),
            this.calculateYearStatistics(year),
            this.buildYearTimeline(year)
        ])

        return {
            year,
            competitions: await this.transformToCompetitionBannerData(competitions),
            statistics,
            timeline,
            championsWall: await this.getChampionsWallData(),
            totalCompetitions: competitions.length,
            completedCompetitions: competitions.filter(c => c.status === 'completed').length,
            ongoingCompetitions: competitions.filter(c => c.status === 'ongoing').length
        }
    }
}
```

### 3.5 è£èª‰æ®¿å ‚æœåŠ¡ ğŸ†•

#### 3.5.1 æ ¸å¿ƒæœåŠ¡è®¾è®¡
**éœ€æ±‚èƒŒæ™¯**ï¼šç”²æ–¹è¦æ±‚å°†"æ•°æ®ä¸­å¿ƒ"é‡å‘½åä¸º"è£èª‰æ®¿å ‚"ï¼Œä½œä¸ºå®˜æ–¹æ•°æ®å±•ç¤ºä¸­å¿ƒï¼Œè®°å½•å†å²è£èª‰ã€‚

```typescript
// è£èª‰æ®¿å ‚æœåŠ¡
class HonorHallService {
    constructor(
        private competitionRepository: CompetitionRepository,
        private teamRepository: TeamRepository,
        private scoreRepository: ScoreRecordRepository,
        private seasonRepository: SeasonRepository,
        private cacheService: CacheService
    ) {}

    // è·å–èµ›å­£è£èª‰æ•°æ®
    async getSeasonHonorData(seasonId: string): Promise<SeasonHonorData> {
        const cacheKey = `honor:season:${seasonId}`;
        let data = await this.cacheService.get(cacheKey);

        if (!data) {
            data = await this.calculateSeasonHonorData(seasonId);
            await this.cacheService.set(cacheKey, data, 3600); // 1å°æ—¶ç¼“å­˜
        }

        return data;
    }

    // è®¡ç®—èµ›å­£è£èª‰æ•°æ®
    private async calculateSeasonHonorData(seasonId: string): Promise<SeasonHonorData> {
        const [
            regionalHonors,
            globalHonors,
            intercontinentalHonors,
            annualRankings,
            statistics
        ] = await Promise.all([
            this.getRegionalHonors(seasonId),
            this.getGlobalHonors(seasonId),
            this.getIntercontinentalHonors(seasonId),
            this.getAnnualRankings(seasonId),
            this.getSeasonStatistics(seasonId)
        ]);

        return {
            seasonId,
            seasonYear: await this.getSeasonYear(seasonId),
            regionalHonors,
            globalHonors,
            intercontinentalHonors,
            annualRankings,
            statistics,
            lastUpdated: new Date()
        };
    }

    // è·å–èµ›åŒºèµ›è£èª‰ï¼ˆæ˜¥å­£èµ› + å¤å­£èµ›ï¼‰
    private async getRegionalHonors(seasonId: string): Promise<RegionalHonorsData> {
        const regions = await this.getActiveRegions();

        const springHonors = await Promise.all(
            regions.map(region => this.getRegionCompetitionHonors(seasonId, region.id, 'spring'))
        );

        const summerHonors = await Promise.all(
            regions.map(region => this.getRegionCompetitionHonors(seasonId, region.id, 'summer'))
        );

        return {
            spring: springHonors.filter(honor => honor !== null),
            summer: summerHonors.filter(honor => honor !== null)
        };
    }

    // è·å–å•ä¸ªèµ›åŒºçš„èµ›äº‹è£èª‰
    private async getRegionCompetitionHonors(
        seasonId: string,
        regionId: string,
        competitionType: 'spring' | 'summer'
    ): Promise<RegionalHonor | null> {
        // æŸ¥æ‰¾è¯¥èµ›åŒºè¯¥ç±»å‹çš„å­£åèµ›
        const playoffCompetition = await this.competitionRepository.findRegionPlayoffs(
            seasonId,
            regionId,
            competitionType
        );

        if (!playoffCompetition || playoffCompetition.status !== 'completed') {
            return null;
        }

        // è·å–å‰ä¸‰åé˜Ÿä¼
        const rankings = await this.getCompetitionRankings(playoffCompetition.id);
        const region = await this.regionRepository.findById(regionId);

        return {
            regionId,
            regionName: region.name,
            competitionId: playoffCompetition.id,
            competitionType,
            champion: await this.buildTeamAchievement(rankings[0], playoffCompetition),
            runnerUp: await this.buildTeamAchievement(rankings[1], playoffCompetition),
            thirdPlace: await this.buildTeamAchievement(rankings[2], playoffCompetition)
        };
    }

    // è·å–å…¨çƒèµ›è£èª‰ï¼ˆMSI + ä¸–ç•Œèµ›ï¼‰
    private async getGlobalHonors(seasonId: string): Promise<GlobalHonorsData> {
        const [msiHonor, worldsHonor] = await Promise.all([
            this.getGlobalCompetitionHonor(seasonId, 'msi'),
            this.getGlobalCompetitionHonor(seasonId, 'worlds')
        ]);

        return {
            msi: msiHonor,
            worlds: worldsHonor
        };
    }

    // è·å–å¹´åº¦ç§¯åˆ†æ’å
    private async getAnnualRankings(seasonId: string): Promise<AnnualRankingsData> {
        const season = await this.seasonRepository.findById(seasonId);

        // è®¡ç®—å¹´åº¦æ€»ç§¯åˆ†æ’å
        const overallRankings = await this.calculateOverallRankings(season.year);

        // è®¡ç®—å„èµ›åŒºå‰ä¸‰
        const regions = await this.getActiveRegions();
        const regionalRankings = await Promise.all(
            regions.map(region => this.calculateRegionalTopThree(season.year, region.id))
        );

        return {
            topThree: overallRankings.slice(0, 3),
            regionalTop: regionalRankings
        };
    }

    // è·å–æ‰€æœ‰å†å²è®°å½•
    async getAllHistoricalRecords(): Promise<HistoricalRecordsData> {
        const seasons = await this.seasonRepository.findAllCompleted();

        const records = await Promise.all(
            seasons.map(async (season) => {
                const honorData = await this.getSeasonHonorData(season.id);
                return {
                    seasonId: season.id,
                    seasonYear: season.year,
                    summary: this.createSeasonSummary(honorData)
                };
            })
        );

        return {
            seasons: records,
            totalSeasons: seasons.length,
            totalCompetitions: records.reduce((sum, r) => sum + r.summary.competitionCount, 0),
            allTimeChampions: await this.getAllTimeChampions()
        };
    }
}
```typescript
// èµ›åˆ¶å¼•æ“ - å¤„ç†ä¸åŒç±»å‹èµ›äº‹çš„èµ›ç¨‹ç”Ÿæˆ
class CompetitionEngine {
    // è”èµ›å¸¸è§„èµ›èµ›ç¨‹ç”Ÿæˆ
    generateRegularSeasonSchedule(teams: Team[]): Match[] {
        const matches: Match[] = [];
        const teamCount = teams.length;

        // åŒå¾ªç¯èµ›ç¨‹ç®—æ³•
        for (let round = 0; round < (teamCount - 1) * 2; round++) {
            for (let match = 0; match < teamCount / 2; match++) {
                const home = (round + match) % (teamCount - 1);
                const away = (teamCount - 1 - match + round) % (teamCount - 1);

                // ç¡®ä¿æœ€åä¸€ä¸ªé˜Ÿä¼çš„å¤„ç†
                const homeTeam = home === teamCount - 1 ? teamCount - 1 : home;
                const awayTeam = away === teamCount - 1 ? teamCount - 1 : away;

                matches.push({
                    teamAId: teams[homeTeam].id,
                    teamBId: teams[awayTeam].id,
                    roundNumber: Math.floor(round / 2) + 1,
                    format: 'BO3'
                });
            }
        }

        return matches;
    }

    // å­£åèµ›å¯¹é˜µç”Ÿæˆ
    generatePlayoffsBracket(teams: Team[]): PlayoffsBracket {
        // æ’åºè·å–å‰4å
        const topTeams = teams.slice(0, 4);

        return {
            winnersGroup: [
                { teamA: topTeams[0], teamB: topTeams[1] }
            ],
            losersGroup: [
                { teamA: topTeams[2], teamB: topTeams[3] }
            ]
        };
    }

    // MSIèµ›åˆ¶ç”Ÿæˆ
    generateMSIBracket(teams: Team[]): MSIBracket {
        const legends = teams.filter(t => t.seedType === 'champion');
        const challengers = teams.filter(t => t.seedType === 'runner_up');
        const qualifiers = teams.filter(t => t.seedType === 'third_place');

        return {
            qualifierRound: this.generateQualifierMatches(qualifiers),
            challengerRound: this.generateChallengerMatches(challengers),
            mainTournament: this.generateDoubleEliminationBracket([...legends])
        };
    }

    // æ´²é™…èµ›å››é˜¶æ®µç”Ÿæˆ
    generateIntercontinentalBracket(teams: Team[]): IntercontinentalBracket {
        const legends = teams.slice(0, 4);
        const challengers = teams.slice(4, 8);
        const fighters = teams.slice(8, 16);

        return {
            stage1: this.generateFighterGroups(fighters),
            stage2: this.generateChallengerMatches(challengers),
            stage3: this.generateDoubleEliminationBracket([]),
            stage4: this.generateFinalStageBracket(legends)
        };
    }
}
```

#### 3.3.2 ç§¯åˆ†è®¡ç®—å¼•æ“
```typescript
// ç§¯åˆ†è®¡ç®—å¼•æ“
class ScoringEngine {
    private rules: Map<string, ScoringRule> = new Map();

    constructor() {
        this.initializeScoringRules();
    }

    // åˆå§‹åŒ–ç§¯åˆ†è§„åˆ™
    private initializeScoringRules(): void {
        // è”èµ›ç§¯åˆ†è§„åˆ™
        this.rules.set('league_match', {
            '2-0': 3,
            '2-1': 2,
            '1-2': 1,
            '0-2': 0
        });

        // å­£åèµ›ç§¯åˆ†è§„åˆ™
        this.rules.set('league_playoffs', {
            'champion': 12,
            'runner_up': 10,
            'third_place': 8,
            'fourth_place': 6
        });

        // MSIç§¯åˆ†è§„åˆ™
        this.rules.set('msi', {
            'champion': 20,
            'runner_up': 16,
            'third_place': 12,
            'fourth_place': 8,
            'quarter_finalist': 6,
            'group_stage': 4
        });

        // æ´²é™…èµ›ç§¯åˆ†è§„åˆ™
        this.rules.set('intercontinental', {
            'champion': 35,
            'runner_up': 30,
            'third_place': 25,
            'fourth_place': 20,
            'stage4_semifinal': 15,
            'stage4_quarterfinal': 10,
            'stage3_eliminated': 8,
            'stage2_eliminated': 5,
            'stage1_eliminated': 2
        });
    }

    // è®¡ç®—æ¯”èµ›ç§¯åˆ†
    async calculateMatchScore(match: Match): Promise<ScoreCalculation> {
        const competitionType = await this.getCompetitionType(match.competitionId);
        const rule = this.rules.get(competitionType);

        if (!rule) {
            throw new Error(`No scoring rule found for competition type: ${competitionType}`);
        }

        const scoreKey = `${match.scoreA}-${match.scoreB}`;
        const winnerPoints = rule[scoreKey] || 0;
        const loserPoints = rule[`${match.scoreB}-${match.scoreA}`] || 0;

        return {
            winnerId: match.winnerId,
            winnerPoints,
            loserId: match.winnerId === match.teamAId ? match.teamBId : match.teamAId,
            loserPoints
        };
    }

    // è®¡ç®—å¹´åº¦ç§¯åˆ†æ’å
    async calculateSeasonRanking(seasonYear: number): Promise<TeamRanking[]> {
        const query = `
            SELECT
                t.id,
                t.name,
                t.region_id,
                SUM(sr.points) as total_points,
                COUNT(DISTINCT sr.competition_id) as competitions_played
            FROM teams t
            LEFT JOIN score_records sr ON t.id = sr.team_id AND sr.season_year = $1
            GROUP BY t.id, t.name, t.region_id
            ORDER BY total_points DESC
        `;

        const result = await this.db.query(query, [seasonYear]);
        return result.rows;
    }

    // è®¡ç®—è·¨å¹´åº¦ç§¯åˆ†ï¼ˆæ´²é™…èµ›ç”¨ï¼‰
    async calculateIntercontinentalRanking(year1: number, year2: number): Promise<TeamRanking[]> {
        const query = `
            SELECT
                t.id,
                t.name,
                t.region_id,
                SUM(sr.points) as total_points
            FROM teams t
            LEFT JOIN score_records sr ON t.id = sr.team_id
            WHERE sr.season_year IN ($1, $2)
            GROUP BY t.id, t.name, t.region_id
            ORDER BY total_points DESC
            LIMIT 16
        `;

        const result = await this.db.query(query, [year1, year2]);
        return result.rows;
    }
}
```

### 3.3 æŠ½ç­¾æœåŠ¡

#### 3.3.1 æŠ½ç­¾ç®—æ³•å¼•æ“
```typescript
// æŠ½ç­¾å¼•æ“
class DrawEngine {
    // éšæœºæŠ½ç­¾æ ¸å¿ƒç®—æ³•
    private shuffleArray<T>(array: T[]): T[] {
        const shuffled = [...array];
        for (let i = shuffled.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        return shuffled;
    }

    // Fighterç»„åˆ†ç»„æŠ½ç­¾
    async drawFighterGroups(teams: Team[]): Promise<FighterGroupDraw> {
        if (teams.length !== 8) {
            throw new Error('Fighter groups require exactly 8 teams');
        }

        const shuffledTeams = this.shuffleArray(teams);

        return {
            groupA: shuffledTeams.slice(0, 4),
            groupB: shuffledTeams.slice(4, 8),
            drawTimestamp: new Date(),
            seed: Math.random().toString(36).substring(7)
        };
    }

    // æŒ‘æˆ˜è€…ç»„å®šä½èµ›æŠ½ç­¾
    async drawChallengerMatches(teams: Team[]): Promise<ChallengerDraw> {
        if (teams.length !== 4) {
            throw new Error('Challenger draw requires exactly 4 teams');
        }

        const shuffledTeams = this.shuffleArray(teams);

        return {
            match1: { teamA: shuffledTeams[0], teamB: shuffledTeams[1] },
            match2: { teamA: shuffledTeams[2], teamB: shuffledTeams[3] },
            drawTimestamp: new Date(),
            seed: Math.random().toString(36).substring(7)
        };
    }

    // æ´²é™…èµ›ç¬¬å››é˜¶æ®µæŠ½ç­¾ï¼ˆé¿å¼€åŒèµ›åŒºï¼‰
    async drawFinalStage(legends: Team[], qualifiers: Team[]): Promise<FinalStageDraw> {
        const availableMatchups = this.generateAvailableMatchups(legends, qualifiers);
        const selectedMatchups = this.selectOptimalMatchups(availableMatchups);

        return {
            matchups: selectedMatchups,
            drawTimestamp: new Date(),
            constraints: {
                avoidSameRegion: true,
                seedProtection: true
            }
        };
    }

    // ç”Ÿæˆå¯ç”¨å¯¹é˜µç»„åˆï¼ˆé¿å¼€åŒèµ›åŒºï¼‰
    private generateAvailableMatchups(legends: Team[], qualifiers: Team[]): Matchup[] {
        const matchups: Matchup[] = [];

        for (const legend of legends) {
            for (const qualifier of qualifiers) {
                if (legend.regionId !== qualifier.regionId) {
                    matchups.push({
                        teamA: legend,
                        teamB: qualifier,
                        regionConflict: false
                    });
                }
            }
        }

        return matchups;
    }

    // é€‰æ‹©æœ€ä¼˜å¯¹é˜µç»„åˆ
    private selectOptimalMatchups(availableMatchups: Matchup[]): Matchup[] {
        // ä½¿ç”¨å›æº¯ç®—æ³•æ‰¾åˆ°æ— å†²çªçš„å®Œæ•´å¯¹é˜µç»„åˆ
        const usedTeams = new Set<string>();
        const selectedMatchups: Matchup[] = [];

        for (const matchup of this.shuffleArray(availableMatchups)) {
            if (!usedTeams.has(matchup.teamA.id) && !usedTeams.has(matchup.teamB.id)) {
                selectedMatchups.push(matchup);
                usedTeams.add(matchup.teamA.id);
                usedTeams.add(matchup.teamB.id);
            }
        }

        return selectedMatchups;
    }

    // ä¿å­˜æŠ½ç­¾è®°å½•
    async saveDrawRecord(competitionId: string, phase: string, drawData: any): Promise<void> {
        const query = `
            INSERT INTO draw_records (competition_id, phase, draw_data)
            VALUES ($1, $2, $3)
        `;
        await this.db.query(query, [competitionId, phase, JSON.stringify(drawData)]);
    }
}
```

### 3.4 ç»Ÿè®¡åˆ†ææœåŠ¡

#### 3.4.1 æ•°æ®èšåˆä¸åˆ†æ
```typescript
// ç»Ÿè®¡åˆ†ææœåŠ¡
class StatisticsService {
    // æˆ˜é˜Ÿå†å²äº¤é”‹åˆ†æ
    async getTeamHeadToHead(teamAId: string, teamBId: string): Promise<HeadToHeadStats> {
        const query = `
            SELECT
                m.*,
                c.type as competition_type,
                c.name as competition_name,
                s.year as season_year
            FROM matches m
            JOIN competitions c ON m.competition_id = c.id
            JOIN seasons s ON c.season_id = s.id
            WHERE (m.team_a_id = $1 AND m.team_b_id = $2)
               OR (m.team_a_id = $2 AND m.team_b_id = $1)
            ORDER BY m.completed_at DESC
        `;

        const result = await this.db.query(query, [teamAId, teamBId]);
        const matches = result.rows;

        return {
            totalMatches: matches.length,
            teamAWins: matches.filter(m => m.winner_id === teamAId).length,
            teamBWins: matches.filter(m => m.winner_id === teamBId).length,
            recentMatches: matches.slice(0, 10),
            competitionBreakdown: this.groupMatchesByCompetition(matches),
            winRateTrend: this.calculateWinRateTrend(matches, teamAId)
        };
    }

    // èµ›åŒºå®åŠ›åˆ†æ
    async getRegionAnalysis(): Promise<RegionAnalysis[]> {
        const query = `
            SELECT
                r.id,
                r.name,
                COUNT(t.id) as team_count,
                AVG(t.power_rating) as avg_power_rating,
                SUM(t.total_wins) as total_wins,
                SUM(t.total_matches) as total_matches,
                AVG(CASE WHEN t.total_matches > 0 THEN t.total_wins::float / t.total_matches ELSE 0 END) as avg_win_rate
            FROM regions r
            LEFT JOIN teams t ON r.id = t.region_id
            GROUP BY r.id, r.name
            ORDER BY avg_power_rating DESC
        `;

        const result = await this.db.query(query);
        return result.rows;
    }

    // ç§¯åˆ†è¶‹åŠ¿åˆ†æ
    async getPointsTrend(teamId: string, seasonYear: number): Promise<PointsTrend> {
        const query = `
            SELECT
                sr.*,
                c.type as competition_type,
                c.name as competition_name,
                m.completed_at
            FROM score_records sr
            JOIN competitions c ON sr.competition_id = c.id
            LEFT JOIN matches m ON sr.match_id = m.id
            WHERE sr.team_id = $1 AND sr.season_year = $2
            ORDER BY sr.created_at ASC
        `;

        const result = await this.db.query(query, [teamId, seasonYear]);
        const records = result.rows;

        let cumulativePoints = 0;
        const trendData = records.map(record => {
            cumulativePoints += record.points;
            return {
                date: record.created_at,
                points: record.points,
                cumulativePoints,
                competitionType: record.competition_type,
                competitionName: record.competition_name
            };
        });

        return {
            teamId,
            seasonYear,
            totalPoints: cumulativePoints,
            trendData,
            milestones: this.identifyMilestones(trendData)
        };
    }

    // æ€§èƒ½æŒ‡æ ‡åˆ†æ
    async getPerformanceMetrics(): Promise<PerformanceMetrics> {
        const queries = await Promise.all([
            this.getTopPerformers(),
            this.getCompetitionWinners(),
            this.getRegionDominance(),
            this.getUpsetMatches()
        ]);

        return {
            topPerformers: queries[0],
            competitionWinners: queries[1],
            regionDominance: queries[2],
            upsetMatches: queries[3],
            generatedAt: new Date()
        };
    }

    // é¢„æµ‹æ¨¡å‹ï¼ˆåŸºäºå†å²æ•°æ®ï¼‰
    async generateMatchPrediction(teamAId: string, teamBId: string): Promise<MatchPrediction> {
        const [teamAStats, teamBStats, headToHead] = await Promise.all([
            this.getTeamStatistics(teamAId),
            this.getTeamStatistics(teamBId),
            this.getTeamHeadToHead(teamAId, teamBId)
        ]);

        // ç®€åŒ–çš„é¢„æµ‹ç®—æ³•
        const powerRatingDiff = teamAStats.powerRating - teamBStats.powerRating;
        const formDiff = teamAStats.recentForm - teamBStats.recentForm;
        const headToHeadFactor = headToHead.teamAWins / (headToHead.totalMatches || 1);

        const teamAWinProbability = this.calculateWinProbability(
            powerRatingDiff,
            formDiff,
            headToHeadFactor
        );

        return {
            teamAWinProbability,
            teamBWinProbability: 1 - teamAWinProbability,
            confidence: this.calculateConfidence(headToHead.totalMatches),
            factors: {
                powerRating: powerRatingDiff,
                recentForm: formDiff,
                headToHead: headToHeadFactor
            }
        };
    }
}
```

## å››ã€APIæ¥å£è®¾è®¡

### 4.1 RESTful APIè§„èŒƒ

#### 4.1.1 æ ¸å¿ƒæ¥å£è®¾è®¡ - éœ€æ±‚é€‚é…æ›´æ–° ğŸ†•

**é‡è¦å˜æ›´è¯´æ˜**ï¼š
åŸºäºç”²æ–¹éœ€æ±‚å˜æ›´ï¼ŒAPIæ¥å£è®¾è®¡è¿›è¡Œäº†é‡å¤§è°ƒæ•´ï¼Œä»æ‰‹åŠ¨åˆ›å»ºå¯¼å‘è½¬ä¸ºè‡ªåŠ¨ç”Ÿæˆå¯¼å‘ã€‚

```typescript
// èµ›äº‹ç®¡ç†æ¥å£ - æ›´æ–°ç‰ˆæœ¬
interface CompetitionAPI {
    'GET    /api/competitions'             // è·å–èµ›äº‹åˆ—è¡¨
    'GET    /api/competitions/:id'         // è·å–èµ›äº‹è¯¦æƒ…
    // 'POST   /api/competitions'          // åˆ›å»ºèµ›äº‹ ã€å·²ç§»é™¤ã€‘
    'PUT    /api/competitions/:id/status'  // æ›´æ–°èµ›äº‹çŠ¶æ€ã€æ–°å¢ã€‘
    'POST   /api/competitions/auto-generate' // è§¦å‘è‡ªåŠ¨ç”Ÿæˆã€æ–°å¢ã€‘
    'GET    /api/competitions/:id/banner-data' // è·å–æ¨ªå¹…å±•ç¤ºæ•°æ®ã€æ–°å¢ã€‘
    'GET    /api/competitions/:id/bracket' // è·å–å¯¹é˜µå›¾
    'POST   /api/competitions/:id/draw'    // æ‰§è¡ŒæŠ½ç­¾
    'GET    /api/competitions/:id/standings'  // è·å–ç§¯åˆ†æ¦œ
    'GET    /api/competitions/:id/champions'  // è·å–å† å†›ä¿¡æ¯ã€æ–°å¢ã€‘
}

// è‡ªåŠ¨èµ›äº‹ç”Ÿæˆæ¥å£ ã€å…¨æ–°æ¨¡å—ã€‘
interface AutoTournamentAPI {
    'GET    /api/auto-tournament/rules'           // è·å–è‡ªåŠ¨ç”Ÿæˆè§„åˆ™
    'PUT    /api/auto-tournament/rules/:id'       // æ›´æ–°ç”Ÿæˆè§„åˆ™
    'POST   /api/auto-tournament/check'           // æ‰‹åŠ¨æ£€æŸ¥è§¦å‘æ¡ä»¶
    'POST   /api/auto-tournament/execute/:ruleId' // æ‰§è¡Œç‰¹å®šè§„åˆ™
    'GET    /api/auto-tournament/logs'            // è·å–æ‰§è¡Œæ—¥å¿—
    'POST   /api/auto-tournament/preview'         // é¢„è§ˆç”Ÿæˆç»“æœ
}

// æ¨ªå¹…æ•°æ®æ¥å£ ã€æ–°å¢æ¨¡å—ã€‘
interface BannerAPI {
    'GET    /api/banners/competitions'            // è·å–èµ›äº‹æ¨ªå¹…æ•°æ®
    'GET    /api/banners/competitions/:type'      // æŒ‰ç±»å‹è·å–æ¨ªå¹…
    'GET    /api/banners/champions-wall'          // è·å–å† å†›å¢™æ•°æ®
    'GET    /api/banners/timeline/:year'          // è·å–å¹´åº¦æ—¶é—´çº¿æ•°æ®
}

// è£èª‰æ®¿å ‚æ¥å£ ã€å…¨æ–°æ¨¡å—ã€‘ğŸ†•
interface HonorHallAPI {
    'GET    /api/honor-hall/seasons'              // è·å–å¯ç”¨èµ›å­£åˆ—è¡¨
    'GET    /api/honor-hall/season/:id'           // è·å–æŒ‡å®šèµ›å­£è£èª‰æ•°æ®
    'GET    /api/honor-hall/regional/:seasonId'   // è·å–èµ›åŒºèµ›è£èª‰
    'GET    /api/honor-hall/global/:seasonId'     // è·å–å…¨çƒèµ›è£èª‰
    'GET    /api/honor-hall/rankings/:seasonId'   // è·å–å¹´åº¦ç§¯åˆ†æ’å
    'GET    /api/honor-hall/achievements/:teamId' // è·å–é˜Ÿä¼å†å²æˆå°±
    'GET    /api/honor-hall/statistics/:seasonId' // è·å–èµ›å­£ç»Ÿè®¡æ•°æ®
    'GET    /api/honor-hall/records/all'          // è·å–å†å²è®°å½•æ±‡æ€»
}
```

**æ¥å£è®¾è®¡åŸåˆ™è°ƒæ•´**ï¼š
- **ç§»é™¤åˆ›å»ºç±»æ¥å£**ï¼šæ‰€æœ‰èµ›äº‹åˆ›å»ºé€šè¿‡è‡ªåŠ¨ç”Ÿæˆæœºåˆ¶
- **å¢å¼ºæŸ¥è¯¢æ¥å£**ï¼šæ”¯æŒæ¨ªå¹…å±•ç¤ºæ‰€éœ€çš„èšåˆæ•°æ®
- **æ–°å¢ç›‘å¬æ¥å£**ï¼šæ”¯æŒå‰ç«¯å®æ—¶è·å–è‡ªåŠ¨ç”Ÿæˆç»“æœ
- **ä¼˜åŒ–æ•°æ®ç»“æ„**ï¼šé’ˆå¯¹å¯è§†åŒ–å±•ç¤ºä¼˜åŒ–è¿”å›æ ¼å¼

// èµ›ç¨‹ç®¡ç†æ¥å£
interface ScheduleAPI {
    'GET    /api/schedule/:competitionId'           // è·å–èµ›ç¨‹çŠ¶æ€
    'GET    /api/schedule/:competitionId/round/:round'  // è·å–æŒ‡å®šè½®æ¬¡ä¿¡æ¯
    'POST   /api/schedule/:competitionId/next-round'    // æ¨è¿›åˆ°ä¸‹ä¸€è½®
    'POST   /api/schedule/:competitionId/simulate-round' // æ¨¡æ‹Ÿå½“å‰è½®æ¬¡
    'GET    /api/schedule/:competitionId/scoreboard'    // è·å–ç§¯åˆ†æ¦œ
    'GET    /api/schedule/:competitionId/remaining'     // è·å–å‰©ä½™èµ›ç¨‹
}

// æ¯”èµ›ç®¡ç†æ¥å£
interface MatchAPI {
    'GET    /api/matches'                  // è·å–æ¯”èµ›åˆ—è¡¨
    'GET    /api/matches/:id'              // è·å–æ¯”èµ›è¯¦æƒ…
    'PUT    /api/matches/:id/result'       // æ›´æ–°æ¯”èµ›ç»“æœ
    'POST   /api/matches/:id/simulate'     // æ¨¡æ‹Ÿæ¯”èµ›ç»“æœ
    'GET    /api/matches/upcoming'         // å³å°†è¿›è¡Œçš„æ¯”èµ›
    'GET    /api/matches/recent'           // æœ€è¿‘å®Œæˆçš„æ¯”èµ›
}

// ç»Ÿè®¡åˆ†ææ¥å£
interface StatisticsAPI {
    'GET    /api/statistics/rankings'      // è·å–æ’å
    'GET    /api/statistics/region-analysis'  // èµ›åŒºåˆ†æ
    'GET    /api/statistics/performance-metrics'  // æ€§èƒ½æŒ‡æ ‡
    'GET    /api/statistics/trends/:teamId'   // ç§¯åˆ†è¶‹åŠ¿
    'POST   /api/statistics/predict-match'    // æ¯”èµ›é¢„æµ‹
}
```

#### 4.1.2 è¯·æ±‚å“åº”æ ¼å¼
```typescript
// ç»Ÿä¸€å“åº”æ ¼å¼
interface APIResponse<T> {
    success: boolean;
    data?: T;
    error?: {
        code: string;
        message: string;
        details?: any;
    };
    meta?: {
        pagination?: {
            page: number;
            limit: number;
            total: number;
            totalPages: number;
        };
        timestamp: string;
        requestId: string;
    };
}

// åˆ†é¡µè¯·æ±‚å‚æ•°
interface PaginationParams {
    page?: number;
    limit?: number;
    sortBy?: string;
    sortOrder?: 'asc' | 'desc';
    filter?: Record<string, any>;
}

// é”™è¯¯ç å®šä¹‰
enum ErrorCodes {
    TEAM_NOT_FOUND = 'TEAM_NOT_FOUND',
    COMPETITION_NOT_ACTIVE = 'COMPETITION_NOT_ACTIVE',
    INVALID_MATCH_RESULT = 'INVALID_MATCH_RESULT',
    DRAW_ALREADY_COMPLETED = 'DRAW_ALREADY_COMPLETED',
    INSUFFICIENT_TEAMS = 'INSUFFICIENT_TEAMS',
    ROUND_NOT_READY = 'ROUND_NOT_READY',
    SIMULATION_FAILED = 'SIMULATION_FAILED',
    INVALID_ROUND_NUMBER = 'INVALID_ROUND_NUMBER'
}
```

### 4.2 GraphQL Schemaè®¾è®¡

#### 4.2.1 æ ¸å¿ƒç±»å‹å®šä¹‰
```graphql
# æˆ˜é˜Ÿç±»å‹
type Team {
    id: ID!
    name: String!
    region: Region!
    powerRating: Int!
    foundedDate: Date
    statistics: TeamStatistics!
    matches(limit: Int): [Match!]!
    scores(seasonYear: Int): [ScoreRecord!]!
}

# èµ›äº‹ç±»å‹
type Competition {
    id: ID!
    name: String!
    type: CompetitionType!
    season: Season!
    status: CompetitionStatus!
    format: CompetitionFormat!
    teams: [Team!]!
    matches: [Match!]!
    bracket: Bracket
    standings: [Standing!]!
}

# èµ›ç¨‹ç±»å‹
type Schedule {
    id: ID!
    competition: Competition!
    currentRound: Int!
    totalRounds: Int!
    rounds: [Round!]!
    scoreboard: [TeamScore!]!
    status: ScheduleStatus!
    lastUpdated: DateTime!
}

# è½®æ¬¡ç±»å‹
type Round {
    number: Int!
    status: RoundStatus!
    matches: [Match!]!
    startDate: DateTime
    endDate: DateTime
    isSimulated: Boolean!
}

# é˜Ÿä¼ç§¯åˆ†ç±»å‹
type TeamScore {
    team: Team!
    points: Int!
    matches: Int!
    wins: Int!
    losses: Int!
    ranking: Int!
}

# æ¯”èµ›ç±»å‹
type Match {
    id: ID!
    competition: Competition!
    teamA: Team!
    teamB: Team!
    scoreA: Int!
    scoreB: Int!
    winner: Team
    status: MatchStatus!
    scheduledAt: DateTime
    completedAt: DateTime
    format: MatchFormat!
}

# æŸ¥è¯¢å…¥å£
type Query {
    # æˆ˜é˜ŸæŸ¥è¯¢
    team(id: ID!): Team
    teams(filter: TeamFilter, pagination: Pagination): TeamsConnection!

    # èµ›äº‹æŸ¥è¯¢
    competition(id: ID!): Competition
    competitions(filter: CompetitionFilter): [Competition!]!

    # èµ›ç¨‹æŸ¥è¯¢
    schedule(competitionId: ID!): Schedule
    scheduleRound(competitionId: ID!, round: Int!): Round
    scoreboard(competitionId: ID!): [TeamScore!]!

    # ç»Ÿè®¡æŸ¥è¯¢
    rankings(seasonYear: Int, type: RankingType): [Ranking!]!
    statistics(teamId: ID, competitionId: ID): Statistics!

    # å®æ—¶æ•°æ®
    liveMatches: [Match!]!
    upcomingMatches(limit: Int): [Match!]!
}

# å˜æ›´æ“ä½œ
type Mutation {
    # æˆ˜é˜Ÿæ“ä½œ
    createTeam(input: CreateTeamInput!): Team!
    updateTeam(id: ID!, input: UpdateTeamInput!): Team!

    # æ¯”èµ›æ“ä½œ
    updateMatchResult(id: ID!, result: MatchResultInput!): Match!
    simulateMatch(id: ID!): Match!

    # èµ›ç¨‹æ“ä½œ
    proceedToNextRound(competitionId: ID!): RoundResult!
    simulateRound(competitionId: ID!, round: Int!): SimulationResult!

    # èµ›äº‹æ“ä½œ
    generateSchedule(competitionId: ID!): Competition!
    executeDraw(competitionId: ID!, phase: String!): DrawResult!
}

# è®¢é˜…ï¼ˆå®æ—¶æ›´æ–°ï¼‰
type Subscription {
    matchUpdated(competitionId: ID): Match!
    roundCompleted(competitionId: ID!): RoundResult!
    scoreboardUpdated(competitionId: ID!): [TeamScore!]!
    rankingsUpdated(seasonYear: Int): [Ranking!]!
    drawExecuted(competitionId: ID!): DrawResult!
}
```

## äº”ã€æŠ€æœ¯å¼€å‘è§„åˆ’

### 5.1 å¼€å‘é˜¶æ®µè§„åˆ’

#### é˜¶æ®µä¸€ï¼šåŸºç¡€æ¶æ„æ­å»ºï¼ˆ7å¤©ï¼‰
**ä»»åŠ¡æ¸…å•**ï¼š
1. **é¡¹ç›®åˆå§‹åŒ–**ï¼ˆ2å¤©ï¼‰ï¼š
   - Node.js + TypeScripté¡¹ç›®æ­å»º
   - Express.jsæ¡†æ¶é…ç½®
   - ESLint + Prettierä»£ç è§„èŒƒ
   - é¡¹ç›®ç›®å½•ç»“æ„è®¾è®¡
   - Dockerå®¹å™¨åŒ–é…ç½®

2. **æ•°æ®åº“è®¾è®¡**ï¼ˆ3å¤©ï¼‰ï¼š
   - PostgreSQLæ•°æ®åº“è®¾è®¡
   - è¡¨ç»“æ„åˆ›å»ºä¸ç´¢å¼•ä¼˜åŒ–
   - æ•°æ®åº“è¿æ¥æ± é…ç½®
   - è¿ç§»è„šæœ¬ç¼–å†™
   - ç§å­æ•°æ®å‡†å¤‡

3. **åŸºç¡€æœåŠ¡æ¡†æ¶**ï¼ˆ2å¤©ï¼‰ï¼š
   - ä¾èµ–æ³¨å…¥å®¹å™¨é…ç½®
   - æ—¥å¿—ç³»ç»Ÿé›†æˆ
   - é”™è¯¯å¤„ç†ä¸­é—´ä»¶
   - é…ç½®ç®¡ç†ç³»ç»Ÿ
   - å¥åº·æ£€æŸ¥ç«¯ç‚¹

#### é˜¶æ®µäºŒï¼šæ ¸å¿ƒä¸šåŠ¡æœåŠ¡å¼€å‘ï¼ˆ18å¤©ï¼‰
**ä»»åŠ¡æ¸…å•**ï¼š
1. **æˆ˜é˜Ÿç®¡ç†æœåŠ¡**ï¼ˆ3å¤©ï¼‰ï¼š
   - TeamServiceä¸šåŠ¡é€»è¾‘
   - TeamRepositoryæ•°æ®è®¿é—®
   - æˆ˜é˜ŸCRUDæ¥å£
   - æˆ˜é˜Ÿç»Ÿè®¡è®¡ç®—
   - ç¼“å­˜ç­–ç•¥å®ç°

2. **èµ›ç¨‹ç®¡ç†æœåŠ¡**ï¼ˆ6å¤©ï¼‰ï¼š
   - ScheduleServiceæ ¸å¿ƒé€»è¾‘
   - æˆ˜åŠ›æ¨¡æ‹Ÿå¼•æ“å¼€å‘
   - ä¸‹ä¸€è½®æ¨è¿›ç®—æ³•
   - ç§¯åˆ†æ›´æ–°æœºåˆ¶
   - å®æ—¶çŠ¶æ€åŒæ­¥

3. **èµ›äº‹ç®¡ç†æœåŠ¡**ï¼ˆ5å¤©ï¼‰ï¼š
   - CompetitionServiceæ ¸å¿ƒé€»è¾‘
   - èµ›åˆ¶å¼•æ“å¼€å‘
   - èµ›ç¨‹ç”Ÿæˆç®—æ³•
   - å¯¹é˜µå›¾æ•°æ®ç»“æ„
   - èµ›äº‹çŠ¶æ€ç®¡ç†

4. **æ¯”èµ›ç®¡ç†æœåŠ¡**ï¼ˆ4å¤©ï¼‰ï¼š
   - MatchServiceä¸šåŠ¡é€»è¾‘
   - èƒœè´Ÿåˆ¤å®šç®—æ³•
   - æ¯”èµ›ç»“æœéªŒè¯
   - å®æ—¶æ›´æ–°æœºåˆ¶
   - æ¨¡æ‹ŸåŠŸèƒ½å®ç°

#### é˜¶æ®µä¸‰ï¼šé«˜çº§åŠŸèƒ½å¼€å‘ï¼ˆ10å¤©ï¼‰
**ä»»åŠ¡æ¸…å•**ï¼š
1. **ç§¯åˆ†è®¡ç®—æœåŠ¡**ï¼ˆ4å¤©ï¼‰ï¼š
   - ScoringEngineæ ¸å¿ƒç®—æ³•
   - ç§¯åˆ†è§„åˆ™é…ç½®åŒ–
   - æ’åè®¡ç®—é€»è¾‘
   - è·¨å¹´åº¦ç§¯åˆ†æ±‡æ€»
   - æ•°æ®ä¸€è‡´æ€§ä¿è¯

2. **æŠ½ç­¾ç³»ç»Ÿ**ï¼ˆ3å¤©ï¼‰ï¼š
   - DrawEngineæŠ½ç­¾ç®—æ³•
   - éšæœºæ€§ä¿è¯æœºåˆ¶
   - è§„åˆ™çº¦æŸå¤„ç†
   - æŠ½ç­¾å†å²è®°å½•
   - å¯è§†åŒ–æ•°æ®å‡†å¤‡

2. **ç»Ÿè®¡åˆ†ææœåŠ¡**ï¼ˆ3å¤©ï¼‰ï¼š
   - StatisticsServiceåˆ†æé€»è¾‘
   - æ•°æ®èšåˆç®—æ³•
   - è¶‹åŠ¿åˆ†æè®¡ç®—
   - é¢„æµ‹æ¨¡å‹å®ç°
   - æ€§èƒ½æŒ‡æ ‡ç»Ÿè®¡

3. **GraphQLæ¥å£**ï¼ˆ2å¤©ï¼‰ï¼š
   - Schemaè®¾è®¡å®ç°
   - Resolverå‡½æ•°ç¼–å†™
   - å®æ—¶è®¢é˜…åŠŸèƒ½
   - æŸ¥è¯¢ä¼˜åŒ–
   - æ•°æ®åŠ è½½å™¨

#### é˜¶æ®µå››ï¼šç³»ç»Ÿé›†æˆä¸ä¼˜åŒ–ï¼ˆ8å¤©ï¼‰
**ä»»åŠ¡æ¸…å•**ï¼š
1. **ç¼“å­˜ç³»ç»Ÿ**ï¼ˆ2å¤©ï¼‰ï¼š
   - Redisç¼“å­˜ç­–ç•¥
   - ç¼“å­˜å¤±æ•ˆæœºåˆ¶
   - åˆ†å¸ƒå¼ç¼“å­˜
   - æ€§èƒ½ç›‘æ§

2. **æ¶ˆæ¯é˜Ÿåˆ—**ï¼ˆ2å¤©ï¼‰ï¼š
   - å¼‚æ­¥ä»»åŠ¡å¤„ç†
   - äº‹ä»¶é©±åŠ¨æ¶æ„
   - æ¶ˆæ¯å¯é æ€§ä¿è¯
   - å¤±è´¥é‡è¯•æœºåˆ¶

3. **æ€§èƒ½ä¼˜åŒ–**ï¼ˆ2å¤©ï¼‰ï¼š
   - æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–
   - APIå“åº”æ—¶é—´ä¼˜åŒ–
   - å†…å­˜ä½¿ç”¨ä¼˜åŒ–
   - å¹¶å‘å¤„ç†ä¼˜åŒ–

4. **å®‰å…¨åŠ å›º**ï¼ˆ2å¤©ï¼‰ï¼š
   - è¾“å…¥éªŒè¯åŠ å¼º
   - SQLæ³¨å…¥é˜²æŠ¤
   - è¯·æ±‚é¢‘ç‡é™åˆ¶
   - æ•°æ®åŠ å¯†å¤„ç†

#### é˜¶æ®µäº”ï¼šæµ‹è¯•ä¸éƒ¨ç½²ï¼ˆ5å¤©ï¼‰
**ä»»åŠ¡æ¸…å•**ï¼š
1. **æµ‹è¯•ä½“ç³»**ï¼ˆ3å¤©ï¼‰ï¼š
   - å•å…ƒæµ‹è¯•ç¼–å†™
   - é›†æˆæµ‹è¯•å®ç°
   - APIæ¥å£æµ‹è¯•
   - æ€§èƒ½å‹åŠ›æµ‹è¯•
   - æµ‹è¯•è¦†ç›–ç‡åˆ†æ

2. **éƒ¨ç½²å‡†å¤‡**ï¼ˆ2å¤©ï¼‰ï¼š
   - ç”Ÿäº§ç¯å¢ƒé…ç½®
   - CI/CDæµæ°´çº¿
   - ç›‘æ§å‘Šè­¦ç³»ç»Ÿ
   - å¤‡ä»½æ¢å¤æ–¹æ¡ˆ
   - æ–‡æ¡£ç¼–å†™

### 5.2 æŠ€æœ¯é£é™©æ§åˆ¶

#### 5.2.1 æ€§èƒ½é£é™©
**é£é™©ç‚¹**ï¼š
- å¤æ‚ç§¯åˆ†è®¡ç®—å¯¼è‡´å“åº”å»¶è¿Ÿ
- å¤§é‡å¹¶å‘è¯·æ±‚æ•°æ®åº“å‹åŠ›
- å®æ—¶æ›´æ–°é¢‘ç¹å½±å“ç³»ç»Ÿç¨³å®šæ€§

**åº”å¯¹æªæ–½**ï¼š
- å¼‚æ­¥ä»»åŠ¡å¤„ç†é‡è®¡ç®—é€»è¾‘
- æ•°æ®åº“è¯»å†™åˆ†ç¦»å’Œåˆ†ç‰‡
- ç¼“å­˜çƒ­ç‚¹æ•°æ®å‡å°‘æ•°æ®åº“è®¿é—®
- é™æµå’Œç†”æ–­æœºåˆ¶

#### 5.2.2 æ•°æ®ä¸€è‡´æ€§é£é™©
**é£é™©ç‚¹**ï¼š
- ç§¯åˆ†è®¡ç®—é”™è¯¯å¯¼è‡´æ’åå¼‚å¸¸
- å¹¶å‘æ›´æ–°å¯¼è‡´æ•°æ®å†²çª
- åˆ†å¸ƒå¼äº‹åŠ¡ä¸€è‡´æ€§é—®é¢˜

**åº”å¯¹æªæ–½**ï¼š
- æ•°æ®åº“äº‹åŠ¡ç¡®ä¿åŸå­æ€§
- ä¹è§‚é”å¤„ç†å¹¶å‘å†²çª
- äº‹ä»¶æº¯æºè®°å½•æ‰€æœ‰å˜æ›´
- å®šæœŸæ•°æ®æ ¡éªŒæœºåˆ¶

#### 5.2.3 æ‰©å±•æ€§é£é™©
**é£é™©ç‚¹**ï¼š
- å•ä½“æ¶æ„æ‰©å±•å›°éš¾
- æ•°æ®åº“æˆä¸ºæ€§èƒ½ç“¶é¢ˆ
- ä¸šåŠ¡é€»è¾‘è€¦åˆåº¦é«˜

**åº”å¯¹æªæ–½**ï¼š
- å¾®æœåŠ¡æ¶æ„é¢„ç•™æ‰©å±•ç©ºé—´
- æ•°æ®åº“åˆ†åº“åˆ†è¡¨ç­–ç•¥
- é¢†åŸŸé©±åŠ¨è®¾è®¡é™ä½è€¦åˆ
- æœåŠ¡åŒ–æ‹†åˆ†æ–¹æ¡ˆ

## å…­ã€ç›‘æ§ä¸è¿ç»´

### 6.1 ç›‘æ§ä½“ç³»

#### 6.1.1 åº”ç”¨ç›‘æ§
```typescript
// æ€§èƒ½ç›‘æ§ä¸­é—´ä»¶
class PerformanceMonitor {
    collectMetrics(req: Request, res: Response, next: NextFunction) {
        const startTime = Date.now();

        res.on('finish', () => {
            const duration = Date.now() - startTime;

            // è®°å½•å“åº”æ—¶é—´
            this.metricsCollector.recordResponseTime(
                req.route?.path,
                req.method,
                res.statusCode,
                duration
            );

            // è®°å½•é”™è¯¯ç‡
            if (res.statusCode >= 400) {
                this.metricsCollector.recordError(
                    req.route?.path,
                    req.method,
                    res.statusCode
                );
            }
        });

        next();
    }
}

// ä¸šåŠ¡æŒ‡æ ‡ç›‘æ§
class BusinessMetrics {
    async recordMatchResult(match: Match) {
        await this.metricsCollector.increment('matches.completed');
        await this.metricsCollector.gauge('matches.average_duration', match.duration);
    }

    async recordUserActivity(userId: string, action: string) {
        await this.metricsCollector.increment(`user.${action}`);
        await this.metricsCollector.set('users.active', userId);
    }
}
```

#### 6.1.2 å‘Šè­¦é…ç½®
```yaml
# å‘Šè­¦è§„åˆ™é…ç½®
alerts:
  - name: high_response_time
    condition: avg(response_time) > 1000ms
    duration: 5m
    actions:
      - email: tech-team@company.com
      - slack: #alerts

  - name: high_error_rate
    condition: error_rate > 5%
    duration: 2m
    actions:
      - email: tech-team@company.com
      - pager: on-call-engineer

  - name: database_connection_pool_exhausted
    condition: db_pool_usage > 90%
    duration: 1m
    actions:
      - email: dba-team@company.com
      - auto_scale: database_pool
```

### 6.2 æ—¥å¿—ç®¡ç†

#### 6.2.1 æ—¥å¿—æ ‡å‡†åŒ–
```typescript
// ç»“æ„åŒ–æ—¥å¿—
class Logger {
    private winston: Winston.Logger;

    constructor() {
        this.winston = winston.createLogger({
            format: winston.format.combine(
                winston.format.timestamp(),
                winston.format.errors({ stack: true }),
                winston.format.json()
            ),
            transports: [
                new winston.transports.File({ filename: 'app.log' }),
                new winston.transports.Console({
                    format: winston.format.simple()
                })
            ]
        });
    }

    logBusinessEvent(event: BusinessEvent) {
        this.winston.info('Business Event', {
            eventType: event.type,
            entityId: event.entityId,
            entityType: event.entityType,
            userId: event.userId,
            timestamp: event.timestamp,
            metadata: event.metadata
        });
    }

    logAPIRequest(req: Request, res: Response, duration: number) {
        this.winston.info('API Request', {
            method: req.method,
            url: req.url,
            statusCode: res.statusCode,
            duration,
            userAgent: req.get('User-Agent'),
            ip: req.ip
        });
    }
}
```

## ä¸ƒã€å®‰å…¨ä¸æ•°æ®ä¿æŠ¤

### 7.1 å®‰å…¨ç­–ç•¥

#### 7.1.1 è®¤è¯æˆæƒ
```typescript
// JWTè®¤è¯ä¸­é—´ä»¶
class AuthenticationMiddleware {
    async authenticate(req: Request, res: Response, next: NextFunction) {
        try {
            const token = this.extractToken(req);
            if (!token) {
                return res.status(401).json({ error: 'No token provided' });
            }

            const payload = jwt.verify(token, process.env.JWT_SECRET!);
            req.user = await this.userService.getUserById(payload.sub);
            next();
        } catch (error) {
            return res.status(401).json({ error: 'Invalid token' });
        }
    }

    authorize(roles: string[]) {
        return (req: Request, res: Response, next: NextFunction) => {
            if (!req.user || !roles.includes(req.user.role)) {
                return res.status(403).json({ error: 'Insufficient permissions' });
            }
            next();
        };
    }
}
```

#### 7.1.2 è¾“å…¥éªŒè¯
```typescript
// æ•°æ®éªŒè¯ä¸­é—´ä»¶
class ValidationMiddleware {
    static validateTeamCreation = [
        body('name').isLength({ min: 1, max: 100 }).trim().escape(),
        body('regionId').isUUID(),
        body('powerRating').isInt({ min: 0, max: 100 }),
        body('foundedDate').optional().isISO8601(),

        (req: Request, res: Response, next: NextFunction) => {
            const errors = validationResult(req);
            if (!errors.isEmpty()) {
                return res.status(400).json({
                    error: 'Validation failed',
                    details: errors.array()
                });
            }
            next();
        }
    ];
}
```

### 7.2 æ•°æ®å¤‡ä»½ä¸æ¢å¤

#### 7.2.1 å¤‡ä»½ç­–ç•¥
```bash
#!/bin/bash
# æ•°æ®åº“å¤‡ä»½è„šæœ¬

DB_NAME="esports_simulator"
BACKUP_DIR="/var/backups/postgresql"
DATE=$(date +%Y%m%d_%H%M%S)

# å…¨é‡å¤‡ä»½
pg_dump -h localhost -U postgres -d $DB_NAME -f $BACKUP_DIR/full_backup_$DATE.sql

# å¢é‡å¤‡ä»½
pg_basebackup -h localhost -U postgres -D $BACKUP_DIR/incremental_$DATE -Ft -z

# æ¸…ç†æ—§å¤‡ä»½
find $BACKUP_DIR -name "*.sql" -mtime +7 -delete
find $BACKUP_DIR -name "incremental_*" -mtime +3 -delete
```

## å…«ã€æŠ€æœ¯æ–¹æ¡ˆæ€»ç»“

### 8.1 æ¶æ„ä¼˜åŠ¿
1. **å¾®æœåŠ¡å‡†å¤‡**ï¼šæ¨¡å—åŒ–è®¾è®¡æ”¯æŒåç»­æœåŠ¡æ‹†åˆ†
2. **é«˜æ€§èƒ½**ï¼šç¼“å­˜ç­–ç•¥å’Œæ•°æ®åº“ä¼˜åŒ–ç¡®ä¿å“åº”é€Ÿåº¦
3. **å¯æ‰©å±•**ï¼šæ’ä»¶åŒ–èµ›åˆ¶å¼•æ“æ”¯æŒæ–°èµ›åˆ¶æ‰©å±•
4. **å¯é æ€§**ï¼šå®Œå–„çš„é”™è¯¯å¤„ç†å’Œç›‘æ§æœºåˆ¶

### 8.2 æ ¸å¿ƒç‰¹æ€§
1. **å¤æ‚èµ›åˆ¶æ”¯æŒ**ï¼šå››é˜¶æ®µæ´²é™…èµ›ç­‰å¤æ‚èµ›åˆ¶å®Œæ•´å®ç°
2. **å®æ—¶è®¡ç®—**ï¼šç§¯åˆ†æ’åå®æ—¶æ›´æ–°ï¼Œæ•°æ®ä¸€è‡´æ€§ä¿è¯
3. **æ™ºèƒ½æŠ½ç­¾**ï¼šçº¦æŸæ¡ä»¶ä¸‹çš„éšæœºæŠ½ç­¾ç®—æ³•
4. **æ•°æ®åˆ†æ**ï¼šä¸°å¯Œçš„ç»Ÿè®¡åˆ†æå’Œè¶‹åŠ¿é¢„æµ‹

### 8.3 æŠ€æœ¯åˆ›æ–°ç‚¹
1. **ç®—æ³•ä¼˜åŒ–**ï¼šé«˜æ•ˆçš„èµ›ç¨‹ç”Ÿæˆå’Œç§¯åˆ†è®¡ç®—ç®—æ³•
2. **ç¼“å­˜ç­–ç•¥**ï¼šå¤šå±‚æ¬¡ç¼“å­˜æå‡ç³»ç»Ÿæ€§èƒ½
3. **äº‹ä»¶é©±åŠ¨**ï¼šåŸºäºäº‹ä»¶çš„å¼‚æ­¥å¤„ç†æœºåˆ¶
4. **æ•°æ®å¯è§†åŒ–**ï¼šä¸ºå‰ç«¯æä¾›ä¸°å¯Œçš„å¯è§†åŒ–æ•°æ®æ”¯æŒ

æœ¬æŠ€æœ¯æ–¹æ¡ˆä¸ºç”µç«èµ›äº‹æ¨¡æ‹Ÿç³»ç»Ÿåç«¯æä¾›äº†å®Œæ•´çš„æŠ€æœ¯æ¶æ„å’Œå®ç°è·¯å¾„ï¼Œç¡®ä¿ç³»ç»Ÿçš„é«˜æ€§èƒ½ã€é«˜å¯ç”¨å’Œå¯æ‰©å±•æ€§ï¼Œæ»¡è¶³å¤æ‚ä¸šåŠ¡éœ€æ±‚ã€‚